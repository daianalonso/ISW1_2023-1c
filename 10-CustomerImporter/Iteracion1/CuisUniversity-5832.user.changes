

----QUIT----(30 May 2023 00:05:32) CuisUniversity-5832.image priorSource: 4928100!

----STARTUP---- (30 May 2023 00:05:33) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5832.image!


----QUIT----(30 May 2023 00:05:33) CuisUniversity-5832.image priorSource: 9366537!

----STARTUP---- (12 June 2023 17:35:14) as D:\windows64\CuisUniversity-5832.image!


----End fileIn of C:\Users\daiana\Downloads\iteracion2\TusLibros.iteracion.2.st----!
!Cashier methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 17:44:01' prior: 50624728!
initializeToCheckout: aCart charging: aCreditCard registeringOn: aSalesBook
	
	cart := aCart.
	creditCard := aCreditCard.
	salesBook := aSalesBook! !

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'DA 6/12/2023 18:07:34'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'DA 6/12/2023 18:07:34'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'DA 6/12/2023 18:07:34'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'DA 6/12/2023 18:07:34'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'DA 6/12/2023 18:07:34'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'DA 6/12/2023 18:07:34'!
PASSED!

!methodRemoval: Cashier #initializeToCheckout:charging:registeringOn: stamp: 'DA 6/12/2023 18:07:42'!
initializeToCheckout: aCart charging: aCreditCard registeringOn: aSalesBook
	
	cart := aCart.
	creditCard := aCreditCard.
	salesBook := aSalesBook!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'DA 6/12/2023 18:07:49'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'DA 6/12/2023 18:07:49'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'DA 6/12/2023 18:07:49'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'DA 6/12/2023 18:07:50'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'DA 6/12/2023 18:07:50'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'DA 6/12/2023 18:07:50'!
PASSED!
!CashierTest methodsFor: 'tests' stamp: 'DA 6/12/2023 18:08:15'!
test03CanNotCheckoutWithAnExpiredCreditCard

	| cart salesBook |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	salesBook := OrderedCollection new.
	debitBehavior := [ :anAmount :aCreditCard | self fail.].

	
	self
		should: [ Cashier 
				toCheckout: cart 
				charging: testObjectsFactory expiredCreditCard 
				throught: self
				on: testObjectsFactory today
				registeringOn: salesBook ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | 
			self assert: anError messageText = Cashier canNotChargeAnExpiredCreditCardErrorMessage.
			self assert: salesBook isEmpty ]! !

!methodRemoval: CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'DA 6/12/2023 18:08:15'!
test03CanNotCheckoutWithAnExpiredCreditCart

	| cart salesBook |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	salesBook := OrderedCollection new.
	debitBehavior := [ :anAmount :aCreditCard | self fail.].

	
	self
		should: [ Cashier 
				toCheckout: cart 
				charging: testObjectsFactory expiredCreditCard 
				throught: self
				on: testObjectsFactory today
				registeringOn: salesBook ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | 
			self assert: anError messageText = Cashier canNotChargeAnExpiredCreditCardErrorMessage.
			self assert: salesBook isEmpty ]!

Object subclass: #InstanceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #InstanceTest category: 'TusLibros' stamp: 'DA 6/12/2023 18:37:37'!
Object subclass: #InstanceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

TestCase subclass: #InterfaceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----STARTUP---- (12 June 2023 19:12:29) as D:\windows64\CuisUniversity-5832.image!


----End fileIn of C:\Users\daiana\Downloads\iteracion2\TusLibros.iteracion.2.st----!

TestCase subclass: #InterfaceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #InterfaceTest category: 'TusLibros' stamp: 'DA 6/12/2023 19:13:31'!
TestCase subclass: #InterfaceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!InterfaceTest methodsFor: 'no messages' stamp: 'DA 6/12/2023 19:13:39'!
test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart
! !

----SNAPSHOT----(12 June 2023 19:13:42) CuisUniversity-5832.image priorSource: 9366758!

!classDefinition: #InterfaceTestObjectsFactory category: 'TusLibros' stamp: 'DA 6/12/2023 19:16:42'!
Object subclass: #InterfaceTestObjectsFactory
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:17:07' prior: 50625587!
test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart
	
	|cart aUser aPass|
	aUser := InterfaceTestObjectsFactory validUser.
	aPass := InterfaceTestObjectsFactory validUserPassword.
	cart := self createCart: aUser autenticateWith: aPass.
	self assert: cart isEmpty.! !
!InterfaceTestObjectsFactory methodsFor: 'no messages' stamp: 'DA 6/12/2023 19:17:51'!
validUser
	^true ! !
!InterfaceTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:17:58'!
validUserPassword
	^true ! !

!classDefinition: #InterfaceTest category: 'TusLibros' stamp: 'DA 6/12/2023 19:18:53'!
TestCase subclass: #InterfaceTest
	instanceVariableNames: 'testInterfaceObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:18:50' overrides: 16961394!
setUp 

	testInterfaceObjects := InterfaceTestObjectsFactory new.! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:19:09' prior: 50625603!
test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart
	
	|cart aUser aPass|
	aUser := testInterfaceObjects validUser.
	aPass := testInterfaceObjects validUserPassword.
	cart := self createCart: aUser autenticateWith: aPass.
	self assert: cart isEmpty.! !

!testRun: #InterfaceTest #test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart stamp: 'DA 6/12/2023 19:19:13'!
ERROR!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:19:18'!
createCart: aUser autenticateWith: aPass 
	self shouldBeImplemented.! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:21:14' prior: 50625652!
createCart: aUser autenticateWith: aPass 
	(aUser and: aPass) ifTrue: [].! !

!testRun: #InterfaceTest #test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart stamp: 'DA 6/12/2023 19:21:15'!
ERROR!
!InterfaceTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:21:34'!
validIdCart! !
!InterfaceTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:21:47' prior: 50625668!
validIdCart
	^ 'id valid of cart'.! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:22:08' prior: 50625658!
createCart: aUser autenticateWith: aPass 
	(aUser and: aPass) ifTrue: [^ testInterfaceObjects validIdCart].! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:23:32' prior: 50625637!
test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart
	
	|cart aUser aPass|
	aUser := testInterfaceObjects validUser.
	aPass := testInterfaceObjects validUserPassword.
	cart := self createCart: aUser autenticateWith: aPass.
	self assert: cart isValid.! !

!testRun: #InterfaceTest #test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart stamp: 'DA 6/12/2023 19:23:35'!
ERROR!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:23:55' prior: 50625684!
test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart
	
	|cart aUser aPass|
	aUser := testInterfaceObjects validUser.
	aPass := testInterfaceObjects validUserPassword.
	cart := self createCart: aUser autenticateWith: aPass.
	self assert: (self isValid: cart).! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:23:59' prior: 50625700!
test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart
	
	|cart aUser aPass|
	aUser := testInterfaceObjects validUser.
	aPass := testInterfaceObjects validUserPassword.
	cart := self createCart: aUser autenticateWith: aPass.
	self assert: (self isValid: cart).! !

!testRun: #InterfaceTest #test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart stamp: 'DA 6/12/2023 19:23:59'!
ERROR!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:24:05'!
isValid: cart 
	self shouldBeImplemented.! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:24:22' prior: 50625727!
isValid: cart 
	^cart = testInterfaceObjects validIdCart.! !

!testRun: #InterfaceTest #test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart stamp: 'DA 6/12/2023 19:24:24'!
PASSED!

!testRun: #InterfaceTest #test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart stamp: 'DA 6/12/2023 19:24:24'!
PASSED!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:28:48'!
test02NotAuthenticateWithIncorrectUserCredentials
	
	|aUser aPass|
	aUser := testInterfaceObjects invalidUser.
	aPass := testInterfaceObjects invalidUserPassword.
	
	self should: [self createCart: aUser autenticateWith: aPass.]
		raise: Error
		withExceptionDo: [:anError|
			self assert: anError messageText equals: self invalidCredentialsErrorMessage.
			].! !
!InterfaceTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:29:07'!
invalidUser
	^false! !
!InterfaceTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:29:15'!
invalidUserPassword
	^false ! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:30:11' prior: 50625677!
createCart: aUser autenticateWith: aPass 
	(aUser and: aPass) ifFalse: [self error: self invalidCredentialsErrorMessage].
	^ testInterfaceObjects validIdCart! !

!testRun: #InterfaceTest #test02NotAuthenticateWithIncorrectUserCredentials stamp: 'DA 6/12/2023 19:30:17'!
ERROR!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:30:21'!
invalidCredentialsErrorMessage
	self shouldBeImplemented.! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:30:31' prior: 50625781!
invalidCredentialsErrorMessage
	^'invalid credentials'! !

!testRun: #InterfaceTest #test02NotAuthenticateWithIncorrectUserCredentials stamp: 'DA 6/12/2023 19:30:32'!
FAILURE!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:31:25' prior: 50625745!
test02NotAuthenticateWithIncorrectUserCredentials
	
	|aUser aPass|
	aUser := testInterfaceObjects invalidUser.
	aPass := testInterfaceObjects invalidUserPassword.
	
	self should: [self createCart: aUser autenticateWith: aPass.]
		raise: Error
		withExceptionDo: [:anError|
			self assert: anError messageText equals: self invalidCredentialsErrorMessage.
			].! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:31:32' prior: 50625769!
createCart: aUser autenticateWith: aPass 
	(aUser and: aPass) ifFalse: [self error: self invalidCredentialsErrorMessage].
	^ testInterfaceObjects validIdCart! !

!testRun: #InterfaceTest #test02NotAuthenticateWithIncorrectUserCredentials stamp: 'DA 6/12/2023 19:32:28'!
PASSED!

!testRun: #InterfaceTest #test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart stamp: 'DA 6/12/2023 19:32:28'!
PASSED!

!testRun: #InterfaceTest #test02NotAuthenticateWithIncorrectUserCredentials stamp: 'DA 6/12/2023 19:32:28'!
PASSED!
!InterfaceTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:35:08'!
invalidIdCart
	^ 'id invalid of cart'.! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:44:03'!
test03CannotListAnInvalidWithInvalidCartId
	
	|cartId|
	cartId := testInterfaceObjects invalidIdCart.
	
	self should: [self listCart: cartId.]
		raise: Error
		withExceptionDo: [:anError|
			self assert: anError messageText equals: self invalidCredentialsErrorMessage.
			].! !

!testRun: #InterfaceTest #test03CannotListAnInvalidWithInvalidCartId stamp: 'DA 6/12/2023 19:44:06'!
FAILURE!
!InterfaceTest methodsFor: 'assertions' stamp: 'DA 6/12/2023 19:44:10' overrides: 16961444!
assert: aRenameMe1 description: aRenameMe2 
	self shouldBeImplemented.! !

!methodRemoval: InterfaceTest #assert:description: stamp: 'DA 6/12/2023 19:44:24'!
assert: aRenameMe1 description: aRenameMe2 
	self shouldBeImplemented.!
!InterfaceTest methodsFor: 'nil' stamp: 'DA 6/12/2023 19:45:03'!
listCart: cartId! !
!InterfaceTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:45:14' prior: 50625672!
validIdCart
	^ true.! !
!InterfaceTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:45:19' prior: 50625830!
invalidIdCart
	^ false.! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:46:28' prior: 50625860!
listCart: cartId
	cartId ifFalse: [self error: self ]! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:46:37' prior: 50625874!
listCart: cartId
	cartId ifFalse: [self error: self invalidCredentialsErrorMessage].! !

!testRun: #InterfaceTest #test03CannotListAnInvalidWithInvalidCartId stamp: 'DA 6/12/2023 19:46:41'!
PASSED!

!testRun: #InterfaceTest #test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart stamp: 'DA 6/12/2023 19:46:41'!
PASSED!

!testRun: #InterfaceTest #test02NotAuthenticateWithIncorrectUserCredentials stamp: 'DA 6/12/2023 19:46:41'!
PASSED!

!testRun: #InterfaceTest #test03CannotListAnInvalidWithInvalidCartId stamp: 'DA 6/12/2023 19:46:41'!
PASSED!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:46:54' prior: 50625834!
test03CannotListAnInvalidWithInvalidCartId
	
	|cartId|
	cartId := testInterfaceObjects invalidIdCart.
	
	self should: [self listCart: cartId.]
		raise: Error
		withExceptionDo: [:anError|
			self assert: anError messageText equals: self invalidCartErrorMessage.
			].! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:47:06'!
invalidCartErrorMessage
	^'invalid cart id'! !

!testRun: #InterfaceTest #test03CannotListAnInvalidWithInvalidCartId stamp: 'DA 6/12/2023 19:47:10'!
FAILURE!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:47:21' prior: 50625879!
listCart: cartId
	cartId ifFalse: [self error: self invalidCartErrorMessage].! !

!testRun: #InterfaceTest #test03CannotListAnInvalidWithInvalidCartId stamp: 'DA 6/12/2023 19:47:24'!
PASSED!

!testRun: #InterfaceTest #test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart stamp: 'DA 6/12/2023 19:47:24'!
PASSED!

!testRun: #InterfaceTest #test02NotAuthenticateWithIncorrectUserCredentials stamp: 'DA 6/12/2023 19:47:24'!
PASSED!

!testRun: #InterfaceTest #test03CannotListAnInvalidWithInvalidCartId stamp: 'DA 6/12/2023 19:47:24'!
PASSED!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:48:58'!
test03CanListValidCartId
	
	|cartId cartList|
	cartId := testInterfaceObjects validIdCart.
	
	cartList := self listCart: cartId.
	self assert: cartList isEmpty not. ! !

!testRun: #InterfaceTest #test03CanListValidCartId stamp: 'DA 6/12/2023 19:49:00'!
ERROR!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:49:16' prior: 50625939!
test03CanListValidCartId
	
	|cartId cartList|
	cartId := testInterfaceObjects validIdCart.
	
	cartList := self listCart: cartId.
	self deny: cartList isEmpty. ! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:49:33' prior: 50625919!
listCart: cartId
	cartId ifFalse: [self error: self invalidCartErrorMessage].
	^ Array with: 'ISBN' with: 'items'.! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:49:50'!
test04CanListValidCartId
	
	|cartId cartList|
	cartId := testInterfaceObjects validIdCart.
	
	cartList := self listCart: cartId.
	self deny: cartList isEmpty. ! !

!methodRemoval: InterfaceTest #test03CanListValidCartId stamp: 'DA 6/12/2023 19:49:50'!
test03CanListValidCartId
	
	|cartId cartList|
	cartId := testInterfaceObjects validIdCart.
	
	cartList := self listCart: cartId.
	self deny: cartList isEmpty. !

!testRun: #InterfaceTest #test04CanListValidCartId stamp: 'DA 6/12/2023 19:49:53'!
PASSED!

!testRun: #InterfaceTest #test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart stamp: 'DA 6/12/2023 19:49:53'!
PASSED!

!testRun: #InterfaceTest #test02NotAuthenticateWithIncorrectUserCredentials stamp: 'DA 6/12/2023 19:49:54'!
PASSED!

!testRun: #InterfaceTest #test03CannotListAnInvalidWithInvalidCartId stamp: 'DA 6/12/2023 19:49:54'!
PASSED!

!testRun: #InterfaceTest #test04CanListValidCartId stamp: 'DA 6/12/2023 19:49:54'!
PASSED!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:52:02'!
test05CannotCheckoutIfCartDontBelongToUser 

	|cartId creditCard aUser aDate|
	cartId := testInterfaceObjects validIdCart.
	self checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate.  
	! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:52:33'!
test06CannotCheckoutIfCreditCardIsExpired

	|cartId creditCard aUser aDate|
	cartId := testInterfaceObjects validIdCart.
	self checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate.  
	! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:53:27'!
test07CheckoutSuccessfullyIfValidFields

	|cartId creditCard aUser aDate|
	cartId := testInterfaceObjects validIdCart.
	self checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate.  
	! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:56:10' prior: 50626000!
test05CannotCheckoutIfCartDontBelongToUser 

	|cartId creditCard aUser aDate|
	cartId := testInterfaceObjects validIdCart.
	creditCard := testInterfaceObjects validCreditCard.
	aUser := testInterfaceObjects validUserNotOwner.
	aDate := Date today.
	
	self should: [self checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate.]
		raise: Error
		withExceptionDo: [:anError | 
			self assert: anError messageText equals: self cartDontBelongUserErrorMessage.
			]
	! !
!InterfaceTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:56:23'!
validCreditCard
	^true ! !
!InterfaceTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:56:57'!
validUserNotOwner
	^false! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:57:42'!
cartDontBelongUserErrorMessage
	^'cart dont belong to user'! !

!testRun: #InterfaceTest #test05CannotCheckoutIfCartDontBelongToUser stamp: 'DA 6/12/2023 19:57:47'!
FAILURE!

!testRun: #InterfaceTest #test05CannotCheckoutIfCartDontBelongToUser stamp: 'DA 6/12/2023 19:58:02'!
FAILURE!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:58:26' prior: 50626030!
test05CannotCheckoutIfCartDontBelongToUser 

	|cartId creditCard aUser aDate|
	cartId := testInterfaceObjects validIdCart.
	creditCard := testInterfaceObjects validCreditCard.
	aUser := testInterfaceObjects validUserNotOwner.
	aDate := Date today.
	self checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate.
	
	self should: [self checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate.]
		raise: Error
		withExceptionDo: [:anError | 
			self assert: anError messageText equals: self cartDontBelongUserErrorMessage.
			]
	! !

!testRun: #InterfaceTest #test05CannotCheckoutIfCartDontBelongToUser stamp: 'DA 6/12/2023 19:58:27'!
ERROR!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:58:33'!
checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate 
	self shouldBeImplemented.! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:59:06' prior: 50626093!
checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate 
	(cartId and: aUser) ifFalse: [self error: self cartDontBelongUserErrorMessage]! !

!testRun: #InterfaceTest #test05CannotCheckoutIfCartDontBelongToUser stamp: 'DA 6/12/2023 19:59:07'!
ERROR!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 19:59:14' prior: 50626069!
test05CannotCheckoutIfCartDontBelongToUser 

	|cartId creditCard aUser aDate|
	cartId := testInterfaceObjects validIdCart.
	creditCard := testInterfaceObjects validCreditCard.
	aUser := testInterfaceObjects validUserNotOwner.
	aDate := Date today.
	
	self should: [self checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate.]
		raise: Error
		withExceptionDo: [:anError | 
			self assert: anError messageText equals: self cartDontBelongUserErrorMessage.
			]
	! !

!testRun: #InterfaceTest #test05CannotCheckoutIfCartDontBelongToUser stamp: 'DA 6/12/2023 19:59:14'!
PASSED!

!testRun: #InterfaceTest #test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart stamp: 'DA 6/12/2023 19:59:14'!
PASSED!

!testRun: #InterfaceTest #test02NotAuthenticateWithIncorrectUserCredentials stamp: 'DA 6/12/2023 19:59:15'!
PASSED!

!testRun: #InterfaceTest #test03CannotListAnInvalidWithInvalidCartId stamp: 'DA 6/12/2023 19:59:15'!
PASSED!

!testRun: #InterfaceTest #test04CanListValidCartId stamp: 'DA 6/12/2023 19:59:15'!
PASSED!

!testRun: #InterfaceTest #test05CannotCheckoutIfCartDontBelongToUser stamp: 'DA 6/12/2023 19:59:15'!
PASSED!

!testRun: #InterfaceTest #test06CannotCheckoutIfCreditCardIsExpired stamp: 'DA 6/12/2023 19:59:15'!
ERROR!

!testRun: #InterfaceTest #test07CheckoutSuccessfullyIfValidFields stamp: 'DA 6/12/2023 19:59:15'!
ERROR!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 20:00:19' prior: 50626010!
test06CannotCheckoutIfCreditCardIsExpired

	|cartId creditCard aUser aDate|
	cartId := testInterfaceObjects validIdCart.
	creditCard := testInterfaceObjects invalidCreditCard.
	aUser := testInterfaceObjects validUser.
	aDate := Date today - 1.
	
	self should: [self checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate.]
		raise: Error
		withExceptionDo: [:anError | 
			self assert: anError messageText equals: self expiredCreditCardErrorMessage.
			]
	! !
!InterfaceTestObjectsFactory methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 20:00:33'!
invalidCreditCard
	^false! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 20:01:03'!
expiredCreditCardErrorMessage
	^'credit card expired'! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 20:03:33' prior: 50626100!
checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate 
	(cartId and: aUser) ifFalse: [self error: self cartDontBelongUserErrorMessage].
	(self checkExpiration: creditCard on: aDate) ifTrue: [self error: self expiredCreditCardErrorMessage]! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 20:04:07'!
checkExpiration: creditCard on: aDate
	^ creditCard! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 20:04:22' prior: 50626196!
checkExpiration: creditCard on: aDate
	^ creditCard not! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 20:04:40' prior: 50626158!
test06CannotCheckoutIfCreditCardIsExpired

	|cartId creditCard aUser aDate|
	cartId := testInterfaceObjects validIdCart.
	creditCard := testInterfaceObjects invalidCreditCard.
	aUser := testInterfaceObjects validUser.
	aDate := Date today.
	
	self should: [self checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate.]
		raise: Error
		withExceptionDo: [:anError | 
			self assert: anError messageText equals: self expiredCreditCardErrorMessage.
			]
	! !

!testRun: #InterfaceTest #test06CannotCheckoutIfCreditCardIsExpired stamp: 'DA 6/12/2023 20:04:40'!
PASSED!

!testRun: #InterfaceTest #test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart stamp: 'DA 6/12/2023 20:04:40'!
PASSED!

!testRun: #InterfaceTest #test02NotAuthenticateWithIncorrectUserCredentials stamp: 'DA 6/12/2023 20:04:40'!
PASSED!

!testRun: #InterfaceTest #test03CannotListAnInvalidWithInvalidCartId stamp: 'DA 6/12/2023 20:04:40'!
PASSED!

!testRun: #InterfaceTest #test04CanListValidCartId stamp: 'DA 6/12/2023 20:04:41'!
PASSED!

!testRun: #InterfaceTest #test05CannotCheckoutIfCartDontBelongToUser stamp: 'DA 6/12/2023 20:04:41'!
PASSED!

!testRun: #InterfaceTest #test06CannotCheckoutIfCreditCardIsExpired stamp: 'DA 6/12/2023 20:04:41'!
PASSED!

!testRun: #InterfaceTest #test07CheckoutSuccessfullyIfValidFields stamp: 'DA 6/12/2023 20:04:41'!
ERROR!

!testRun: #InterfaceTest #test07CheckoutSuccessfullyIfValidFields stamp: 'DA 6/12/2023 20:04:41'!
ERROR!

!testRun: #InterfaceTest #test06CannotCheckoutIfCreditCardIsExpired stamp: 'DA 6/12/2023 20:05:14'!
PASSED!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 20:06:00' prior: 50626020!
test07CheckoutSuccessfullyIfValidFields

	|cartId creditCard aUser aDate|
	cartId := testInterfaceObjects validIdCart.
	
	self assert: (self checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate)  
	! !
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 20:06:31' prior: 50626259!
test07CheckoutSuccessfullyIfValidFields

	|cartId creditCard aUser aDate|
	cartId := testInterfaceObjects validIdCart.
	creditCard := testInterfaceObjects validCreditCard.
	aUser := testInterfaceObjects validUser.
	aDate := Date today.
	
	self assert: (self checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate)  
	! !

!testRun: #InterfaceTest #test07CheckoutSuccessfullyIfValidFields stamp: 'DA 6/12/2023 20:06:33'!
ERROR!
!InterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/12/2023 20:06:45' prior: 50626185!
checkoutCart: cartId withCC: creditCard ownedBy: aUser expiringOn: aDate 
	(cartId and: aUser) ifFalse: [self error: self cartDontBelongUserErrorMessage].
	(self checkExpiration: creditCard on: aDate) ifTrue: [self error: self expiredCreditCardErrorMessage].
	^true! !

!testRun: #InterfaceTest #test07CheckoutSuccessfullyIfValidFields stamp: 'DA 6/12/2023 20:06:49'!
PASSED!

!testRun: #InterfaceTest #test01AuthenticateWithCorrectUserCredentialsCreateEmptyCart stamp: 'DA 6/12/2023 20:06:49'!
PASSED!

!testRun: #InterfaceTest #test02NotAuthenticateWithIncorrectUserCredentials stamp: 'DA 6/12/2023 20:06:49'!
PASSED!

!testRun: #InterfaceTest #test03CannotListAnInvalidWithInvalidCartId stamp: 'DA 6/12/2023 20:06:49'!
PASSED!

!testRun: #InterfaceTest #test04CanListValidCartId stamp: 'DA 6/12/2023 20:06:49'!
PASSED!

!testRun: #InterfaceTest #test05CannotCheckoutIfCartDontBelongToUser stamp: 'DA 6/12/2023 20:06:49'!
PASSED!

!testRun: #InterfaceTest #test06CannotCheckoutIfCreditCardIsExpired stamp: 'DA 6/12/2023 20:06:49'!
PASSED!

!testRun: #InterfaceTest #test07CheckoutSuccessfullyIfValidFields stamp: 'DA 6/12/2023 20:06:49'!
PASSED!

----SNAPSHOT----(12 June 2023 20:12:50) CuisUniversity-5832.image priorSource: 9406111!

----QUIT----(12 June 2023 20:13:15) CuisUniversity-5832.image priorSource: 9429563!

----STARTUP---- (14 June 2023 20:12:15) as D:\windows64\CuisUniversity-5832.image!


!classRemoval: #StoreTestObjectsFactory stamp: 'DA 6/14/2023 20:15:22'!
Object subclass: #StoreTestObjectsFactory
	instanceVariableNames: 'today'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #InterfaceTestObjectsFactory stamp: 'DA 6/14/2023 20:15:23'!
Object subclass: #InterfaceTestObjectsFactory
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CreditCard stamp: 'DA 6/14/2023 20:15:23'!
Object subclass: #CreditCard
	instanceVariableNames: 'expiration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cashier stamp: 'DA 6/14/2023 20:15:24'!
Object subclass: #Cashier
	instanceVariableNames: 'cart salesBook merchantProcessor creditCard total'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cart stamp: 'DA 6/14/2023 20:15:24'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #InterfaceTest stamp: 'DA 6/14/2023 20:15:24'!
TestCase subclass: #InterfaceTest
	instanceVariableNames: 'testInterfaceObjects'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CashierTest stamp: 'DA 6/14/2023 20:15:25'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testObjectsFactory debitBehavior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartTest stamp: 'DA 6/14/2023 20:15:25'!
TestCase subclass: #CartTest
	instanceVariableNames: 'testObjectsFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----End fileIn of C:\Users\daiana\Downloads\Telegram Desktop\TusLibros.iteracion.2.5.st----!
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 20:33:05'!
test13AssertExpiredTimeWhenInteractingCart

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 20:37:03' prior: 50627359!
test13AssertExpiredTimeWhenInteractingCart

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 20:37:46' prior: 50627378!
test13AssertExpiredTimeWhenInteractingCart

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 20:37:46'!
ERROR!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 20:37:52'!
addMinutes: aRenameMe1 
	self shouldBeImplemented.! !

!classDefinition: #RestInterface category: 'TusLibros' stamp: 'DA 6/14/2023 20:38:50'!
Object subclass: #RestInterface
	instanceVariableNames: 'authenticationSystem carts catalog lastId merchantProcessor salesBook clock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 20:38:48' prior: 50627419!
addMinutes: anAmountOfMinutes
	clock := clock + Duration anAmountOfMinutes.! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 20:39:20' prior: 50627433!
addMinutes: anAmountOfMinutes
	clock := clock + (Duration minutes: anAmountOfMinutes).! !

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 20:39:22'!
ERROR!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 20:39:42'!
now
	
	^clock! !

!methodRemoval: RestInterface #today stamp: 'DA 6/14/2023 20:39:48'!
today
	
	^DateAndTime now!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 20:40:37' prior: 50627205!
initializeAuthenticatingWith: anAuthenticationSystem acceptingItemsOf: aCatalog merchantProcessor: anMP

	authenticationSystem := anAuthenticationSystem.
	catalog := aCatalog.
	carts := Dictionary new.
	lastId := 0.
	merchantProcessor := anMP.
	clock := DateAndTime now. ! !

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 20:40:47'!
FAILURE!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 20:40:47'!
FAILURE!

!classDefinition: #RestInterface category: 'TusLibros' stamp: 'DA 6/14/2023 21:00:24'!
Object subclass: #RestInterface
	instanceVariableNames: 'authenticationSystem carts catalog lastId merchantProcessor salesBook clock lastUsed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:00:22' prior: 50627152!
add: aBook quantity: anAmount toCartIdentifiedAs: aCartId

	| cart |
	
	cart := carts at: aCartId ifAbsent: [ self signalInvalidCartId ].
	(self now - lastUsed at: aCartId) > 30 ifTrue: [self cartExpiredErrorMessage].
	cart add: anAmount of: aBook ! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:00:48' prior: 50627455!
initializeAuthenticatingWith: anAuthenticationSystem acceptingItemsOf: aCatalog merchantProcessor: anMP

	authenticationSystem := anAuthenticationSystem.
	catalog := aCatalog.
	carts := Dictionary new.
	lastUsed := Dictionary new.
	lastId := 0.
	merchantProcessor := anMP.
	clock := DateAndTime now. ! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:01:31' prior: 50627484!
add: aBook quantity: anAmount toCartIdentifiedAs: aCartId

	| cart |
	
	cart := carts at: aCartId ifAbsent: [ self signalInvalidCartId ].
	(self now - lastUsed at: aCartId) > 30 ifTrue: [self cartExpiredErrorMessage].
	
	cart add: anAmount of: aBook.
	lastUsed at: aCartId put: DateAndTime now.  ! !

!testRun: #RestInterfaceTest #test01CanCreateCartWithValidUserAndPassword stamp: 'DA 6/14/2023 21:02:27'!
PASSED!

!testRun: #RestInterfaceTest #test02CanNotCreateCartWithInvalidUser stamp: 'DA 6/14/2023 21:02:27'!
PASSED!

!testRun: #RestInterfaceTest #test03CanNotCreateCartWithInvalidPassword stamp: 'DA 6/14/2023 21:02:27'!
PASSED!

!testRun: #RestInterfaceTest #test04CanAddItemsToACreatedCart stamp: 'DA 6/14/2023 21:02:27'!
ERROR!

!testRun: #RestInterfaceTest #test05CanNotAddItemToNotCreatedCart stamp: 'DA 6/14/2023 21:02:27'!
PASSED!

!testRun: #RestInterfaceTest #test06CanNotAddItemNotSellByTheStore stamp: 'DA 6/14/2023 21:02:27'!
ERROR!

!testRun: #RestInterfaceTest #test07ListCartOfAnEmptyCartReturnsAnEmptyBag stamp: 'DA 6/14/2023 21:02:27'!
PASSED!

!testRun: #RestInterfaceTest #test08CanNotListCartOfInvalidCartId stamp: 'DA 6/14/2023 21:02:27'!
PASSED!

!testRun: #RestInterfaceTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'DA 6/14/2023 21:02:27'!
ERROR!

!testRun: #RestInterfaceTest #test10CanCheckoutACart stamp: 'DA 6/14/2023 21:02:27'!
ERROR!

!testRun: #RestInterfaceTest #test11CanNotCheckoutANotCreatedCart stamp: 'DA 6/14/2023 21:02:27'!
PASSED!

!testRun: #RestInterfaceTest #test12CanNotCheckoutAnEmptyCart stamp: 'DA 6/14/2023 21:02:27'!
ERROR!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:02:27'!
ERROR!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:02:33'!
ERROR!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:02:42'!
expiredTimeErrorDescription
	self shouldBeImplemented.! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:02:54' prior: 50627568!
expiredTimeErrorDescription
	'Expired session time'! !

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:02:56'!
FAILURE!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:03:16' prior: 50627508!
add: aBook quantity: anAmount toCartIdentifiedAs: aCartId

	| cart |
	
	cart := carts at: aCartId ifAbsent: [ self signalInvalidCartId ].
	(self now - lastUsed at: aCartId) > 30 ifTrue: [self expiredTimeErrorMessage].
	
	cart add: anAmount of: aBook.
	lastUsed at: aCartId put: DateAndTime now.  ! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:03:28' prior: 50627582!
add: aBook quantity: anAmount toCartIdentifiedAs: aCartId

	| cart |
	
	cart := carts at: aCartId ifAbsent: [ self signalInvalidCartId ].
	(self now - lastUsed at: aCartId) > 30 ifTrue: [self expiredTimeErrorDescription].
	
	cart add: anAmount of: aBook.
	lastUsed at: aCartId put: DateAndTime now.  ! !

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:03:38'!
FAILURE!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:03:38'!
FAILURE!
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:04:09' prior: 50627398!
test13AssertExpiredTimeWhenInteractingCart

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:04:11'!
ERROR!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:05:10' prior: 50627595!
add: aBook quantity: anAmount toCartIdentifiedAs: aCartId

	| cart |
	
	cart := carts at: aCartId ifAbsent: [ self signalInvalidCartId ].
	((self now - lastUsed at: aCartId) > 30) ifTrue: [self expiredTimeErrorDescription].
	
	cart add: anAmount of: aBook.
	lastUsed at: aCartId put: DateAndTime now.  ! !

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:05:19'!
ERROR!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:05:19'!
ERROR!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:06:12'!
ERROR!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:07:06' prior: 50627639!
add: aBook quantity: anAmount toCartIdentifiedAs: aCartId

	| cart |
	
	cart := carts at: aCartId ifAbsent: [ self signalInvalidCartId ].
	((self now - (lastUsed at: aCartId)) > 30) ifTrue: [self expiredTimeErrorDescription].
	
	cart add: anAmount of: aBook.
	lastUsed at: aCartId put: DateAndTime now.  ! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:07:17' prior: 50627663!
add: aBook quantity: anAmount toCartIdentifiedAs: aCartId

	| cart |
	
	cart := carts at: aCartId ifAbsent: [ self signalInvalidCartId ].
	(self now - (lastUsed at: aCartId) > 30) ifTrue: [self expiredTimeErrorDescription].
	
	cart add: anAmount of: aBook.
	lastUsed at: aCartId put: DateAndTime now.  ! !

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:07:26'!
ERROR!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:07:26'!
ERROR!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:08:38' prior: 50627182!
createCartFor: aUser authenticatedWith: aPassword

	| cartId |
	
	(self is: aUser authenticatingWith: aPassword) ifFalse: [ self signalInvalidUserAndOrPassword ].
	
	cartId := self generateCartId.
	carts at: cartId put: (Cart acceptingItemsOf: catalog).
	lastUsed at: cartId put: DateAndTime now.
	
	^cartId ! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:08:59' prior: 50627696!
createCartFor: aUser authenticatedWith: aPassword

	| cartId |
	
	(self is: aUser authenticatingWith: aPassword) ifFalse: [ self signalInvalidUserAndOrPassword ].
	
	cartId := self generateCartId.
	carts at: cartId put: (Cart acceptingItemsOf: catalog).
	lastUsed at: cartId put: self now.
	
	^cartId ! !

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:09:17'!
ERROR!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:09:17'!
ERROR!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:10:52'!
ERROR!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:11:10'!
ERROR!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:11:10'!
ERROR!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:11:19'!
ERROR!
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 21:12:21' prior: 50627615!
test13AssertExpiredTimeWhenInteractingCart

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	"nterface add: self validBook quantity: 1 toCartIdentifiedAs: cartId."
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:12:24'!
FAILURE!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 21:12:24'!
FAILURE!

----SNAPSHOT----(14 June 2023 21:14:22) CuisUniversity-5832.image priorSource: 9429652!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 22:31:19' prior: 50627676!
add: aBook quantity: anAmount toCartIdentifiedAs: aCartId

	| cart |
	
	cart := carts at: aCartId ifAbsent: [ self signalInvalidCartId ].
	(self now - (lastUsed at: aCartId) > Duration minutes: 30) ifTrue: [self expiredTimeErrorDescription].
	
	cart add: anAmount of: aBook.
	lastUsed at: aCartId put: DateAndTime now.  ! !

----STARTUP---- (14 June 2023 22:32:21) as D:\windows64\CuisUniversity-5832.image!


!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 22:34:22'!
FAILURE!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 22:34:22'!
FAILURE!
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 22:35:12' prior: 50627743!
test13AssertExpiredTimeWhenInteractingCart

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 22:35:59' prior: 50627676!
add: aBook quantity: anAmount toCartIdentifiedAs: aCartId

	| cart |
	
	cart := carts at: aCartId ifAbsent: [ self signalInvalidCartId ].
	(self now - (lastUsed at: aCartId) > (Duration minutes: 30)) ifTrue: [self expiredTimeErrorDescription].
	
	cart add: anAmount of: aBook.
	lastUsed at: aCartId put: DateAndTime now.  ! !

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 22:36:10'!
FAILURE!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 22:36:10'!
FAILURE!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 22:38:04' prior: 50627803!
add: aBook quantity: anAmount toCartIdentifiedAs: aCartId

	| cart |
	
	cart := carts at: aCartId ifAbsent: [ self signalInvalidCartId ].
	(self now - (lastUsed at: aCartId) > (Duration minutes: 30)) ifTrue: [self signalExpiredTime].
	
	cart add: anAmount of: aBook.
	lastUsed at: aCartId put: DateAndTime now.  ! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 22:38:26'!
signalExpiredTime
	
	self error: self expiredTimeErrorDescription! !

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 22:38:32'!
ERROR!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 22:38:32'!
ERROR!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 22:38:33'!
ERROR!

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 22:38:57'!
ERROR!
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 22:39:06' prior: 50627783!
test13AssertExpiredTimeWhenInteractingCart

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !

!testRun: #RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 22:39:10'!
PASSED!
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 22:39:56'!
test13CartNotAddingItemsWithExpiredSesion

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !

!methodRemoval: RestInterfaceTest #test13AssertExpiredTimeWhenInteractingCart stamp: 'DA 6/14/2023 22:39:56'!
test13AssertExpiredTimeWhenInteractingCart

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		!
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 22:40:17'!
test13CartNotListingItemsWithExpiredSesion

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 22:40:34' prior: 50627167!
checkOutCartIdentifiedAs: aCartId withCreditCardNumbered: aCreditCartNumber ownedBy: anOwner expiringOn: anExpirationMonthOfYear

	| cart |
	
	cart := carts at: aCartId ifAbsent: [self signalInvalidCartId ].
	
	Cashier 
		toCheckout: cart 
		charging: (CreditCard expiringOn: anExpirationMonthOfYear) 
		throught: merchantProcessor 
		on: self clock 
		registeringOn: salesBook! !
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 22:41:14'!
test14CartNotListingItemsWithExpiredSesion

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !

!methodRemoval: RestInterfaceTest #test13CartNotListingItemsWithExpiredSesion stamp: 'DA 6/14/2023 22:41:14'!
test13CartNotListingItemsWithExpiredSesion

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		!
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 22:42:38' prior: 50627946!
test14CartNotListingItemsWithExpiredSesion

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	self
		should: [interface listCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !

!testRun: #RestInterfaceTest #test14CartNotListingItemsWithExpiredSesion stamp: 'DA 6/14/2023 22:42:44'!
FAILURE!

!testRun: #RestInterfaceTest #test14CartNotListingItemsWithExpiredSesion stamp: 'DA 6/14/2023 22:42:44'!
FAILURE!

!testRun: #RestInterfaceTest #test14CartNotListingItemsWithExpiredSesion stamp: 'DA 6/14/2023 22:43:02'!
FAILURE!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 22:43:49' prior: 50627239!
listCartIdentifiedAs: aCartId

	| cart |
	
	cart := carts at: aCartId ifAbsent: [ self signalInvalidCartId ].
	(self now - (lastUsed at: aCartId) > (Duration minutes: 30)) ifTrue: [self signalExpiredTime].
	
	^cart content! !

!testRun: #RestInterfaceTest #test14CartNotListingItemsWithExpiredSesion stamp: 'DA 6/14/2023 22:43:54'!
PASSED!

Object subclass: #CartSessionData
	instanceVariableNames: 'cart id lastUsed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CartSessionData category: 'TusLibros' stamp: 'DA 6/14/2023 22:49:33'!
Object subclass: #CartSessionData
	instanceVariableNames: 'cart id lastUsed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 22:59:53'!
updateCartSession: aCartId
	|cart|
	cart := carts at: aCartId ifAbsent: [ self signalInvalidCartId ].
	(cart isExpired: self now) ifTrue: [self signalExpiredTime].
	cart updateLastUse: self now. ! !

Object subclass: #RestInterface
	instanceVariableNames: 'authenticationSystem carts catalog lastId merchantProcessor salesBook clock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

Object subclass: #RestInterface
	instanceVariableNames: 'authenticationSystem carts catalog lastId merchantProcessor salesBook clock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:03:32' prior: 50628036!
updateCartSession: aCartId
	self assertCartExists: aCartId. 
	self assertCartNotExpired: aCartId.
	self updateLastUseFor: aCartId.! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:04:04'!
assertCartExists: aCartId. 
	carts at: aCartId ifAbsent: [ self signalInvalidCartId ].! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:04:50'!
assertCartNotExpired: aCartId. 
	((carts at: aCartId) isExpired: self now) ifTrue: [self signalExpiredTime].! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:05:48'!
updateLastUseFor: aCartId
	(carts at: aCartId) updateLastUsed: self now. ! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:09:22'!
retrieveCart: aCartId. 
	^carts detect: [:aCart | aCart id = aCartId] ifNone: [ self signalInvalidCartId ].! !

!methodRemoval: RestInterface #assertCartExists: stamp: 'DA 6/14/2023 23:09:30'!
assertCartExists: aCartId. 
	carts at: aCartId ifAbsent: [ self signalInvalidCartId ].!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:09:56' prior: 50628072!
assertCartNotExpired: aCart 
	aCart isExpired: self now ifTrue: [self signalExpiredTime].! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:10:35' prior: 50628059!
updateCartSession: aCartId
	|cart|
	cart := self retrieveCart: aCartId.
	self assertCartNotExpired: cart.
	self updateLastUseFor: cart.! !

!methodRemoval: RestInterface #updateLastUseFor: stamp: 'DA 6/14/2023 23:10:59'!
updateLastUseFor: aCartId
	(carts at: aCartId) updateLastUsed: self now. !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:11:22' prior: 50628102!
updateCartSession: aCartId
	|cart|
	cart := self retrieveCart: aCartId.
	self assertCartNotExpired: cart.
	cart updateLastUsed: self now.! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:13:41' prior: 50627824!
add: aBook quantity: anAmount toCartIdentifiedAs: aCartId
	|cart|
	self updateCartSession: aCartId.
	cart := self retrieveCart: aCartId.
	cart add: anAmount of: aBook.! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:14:31'!
tryUpdateCartSession: aCartId
	|cart|
	cart := self retrieveCart: aCartId.
	self assertCartNotExpired: cart.
	cart updateLastUsed: self now.! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:14:31' prior: 50628123!
add: aBook quantity: anAmount toCartIdentifiedAs: aCartId
	|cart|
	self tryUpdateCartSession: aCartId.
	cart := self retrieveCart: aCartId.
	cart add: anAmount of: aBook.! !

!methodRemoval: RestInterface #updateCartSession: stamp: 'DA 6/14/2023 23:14:31'!
updateCartSession: aCartId
	|cart|
	cart := self retrieveCart: aCartId.
	self assertCartNotExpired: cart.
	cart updateLastUsed: self now.!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:16:24' prior: 50628010!
listCartIdentifiedAs: aCartId
	| cart |
	
	self tryUpdateCartSession: aCartId.
	cart := self retrieveCart: aCartId.
	
	^cart content! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:18:44' prior: 50628084!
retrieveCart: aCartId

	^carts detect: [:aCart | aCart id = aCartId] ifNone: [ self signalInvalidCartId ].! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:19:11' prior: 50627931!
checkOutCartIdentifiedAs: aCartId withCreditCardNumbered: aCreditCartNumber ownedBy: anOwner expiringOn: anExpirationMonthOfYear

	| cart |
	
	cart := carts at: aCartId ifAbsent: [self signalInvalidCartId ].
	
	Cashier 
		toCheckout: cart 
		charging: (CreditCard expiringOn: anExpirationMonthOfYear) 
		throught: merchantProcessor 
		on: self now
		registeringOn: salesBook! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:19:50' prior: 50628096!
assertCartNotExpired: aCart 
	(aCart isExpired: self now) ifTrue: [self signalExpiredTime].! !

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:20:04'!
FAILURE!

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:20:04'!
FAILURE!
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:20:28' prior: 50627878!
test13CartNotAddingItemsWithExpiredSesion

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId.
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:20:47'!
ERROR!

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:21:07'!
ERROR!
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:23:28' prior: 50628199!
test13CartNotAddingItemsWithExpiredSesion

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:24:09' prior: 50628170!
checkOutCartIdentifiedAs: aCartId withCreditCardNumbered: aCreditCartNumber ownedBy: anOwner expiringOn: anExpirationMonthOfYear

	| cart |
	
	cart := self retrieveCart: aCartId.
	
	Cashier 
		toCheckout: cart 
		charging: (CreditCard expiringOn: anExpirationMonthOfYear) 
		throught: merchantProcessor 
		on: self now
		registeringOn: salesBook! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:24:54' prior: 50628244!
checkOutCartIdentifiedAs: aCartId withCreditCardNumbered: aCreditCartNumber ownedBy: anOwner expiringOn: anExpirationMonthOfYear

	| cart |
	self tryUpdateCartSession: aCartId.
	cart := self retrieveCart: aCartId.
	
	Cashier 
		toCheckout: cart 
		charging: (CreditCard expiringOn: anExpirationMonthOfYear) 
		throught: merchantProcessor 
		on: self now
		registeringOn: salesBook! !
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:25:49' prior: 50627495!
initializeAuthenticatingWith: anAuthenticationSystem acceptingItemsOf: aCatalog merchantProcessor: anMP

	authenticationSystem := anAuthenticationSystem.
	catalog := aCatalog.
	carts := OrderedCollection new.
	lastId := 0.
	merchantProcessor := anMP.
	clock := DateAndTime now. ! !

Object subclass: #RestInterface
	instanceVariableNames: 'authenticationSystem carts catalog lastId merchantProcessor salesBook clock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #RestInterface category: 'TusLibros' stamp: 'DA 6/14/2023 23:26:02'!
Object subclass: #RestInterface
	instanceVariableNames: 'authenticationSystem carts catalog lastId merchantProcessor salesBook clock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

Object subclass: #CartSession
	instanceVariableNames: 'cart id lastUsed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CartSession category: 'TusLibros' stamp: 'DA 6/14/2023 23:28:48'!
Object subclass: #CartSession
	instanceVariableNames: 'cart id lastUsed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartSessionData stamp: 'DA 6/14/2023 23:28:53'!
Object subclass: #CartSessionData
	instanceVariableNames: 'cart id lastUsed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:29:14' prior: 50627709!
createCartFor: aUser authenticatedWith: aPassword

	| cartId |
	
	(self is: aUser authenticatingWith: aPassword) ifFalse: [ self signalInvalidUserAndOrPassword ].
	cartId := self generateCartId.
	carts add: (CartSession initiateSessionOf: (Cart acceptingItemsOf: catalog) withId: cartId startingAt: self now).
	
	^cartId ! !

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:29:32'!
ERROR!

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:29:32'!
ERROR!
!CartSession class methodsFor: 'instance creation' stamp: 'DA 6/14/2023 23:29:37'!
initiateSessionOf: aCart withId: aSmallInteger startingAt: aDateAndTime 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeInitiateSessionOf: aCart withId: aSmallInteger startingAt: aDateAndTime ! !
!CartSession class methodsFor: 'instance creation' stamp: 'DA 6/14/2023 23:30:15' prior: 50628340!
initiateSessionOf: aCart withId: aCartId startingAt: aDate 
	^self new initializeInitiateSessionOf: aCart withId: aCartId startingAt: aDate ! !

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:30:16'!
ERROR!

!classDefinition: #CartSession category: 'TusLibros' stamp: 'DA 6/14/2023 23:30:27'!
Object subclass: #CartSession
	instanceVariableNames: 'cart id lastUsed cartId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CartSession category: 'TusLibros' stamp: 'DA 6/14/2023 23:30:27'!
Object subclass: #CartSession
	instanceVariableNames: 'cart id lastUsed cartId date'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CartSession methodsFor: 'initialization' stamp: 'DA 6/14/2023 23:30:27'!
initializeInitiateSessionOf: aCart withId: aCartId startingAt: aDate 
	self shouldBeImplemented.
	cart := aCart.
	cartId := aCartId.
	date := aDate.! !
!CartSession methodsFor: 'initialization' stamp: 'DA 6/14/2023 23:30:42' prior: 50628378!
initializeInitiateSessionOf: aCart withId: aCartId startingAt: aDate 
	cart := aCart.
	cartId := aCartId.
	lastUsed := aDate.! !

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:30:43'!
FAILURE!

Object subclass: #CartSession
	instanceVariableNames: 'cart id lastUsed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CartSession category: 'TusLibros' stamp: 'DA 6/14/2023 23:30:59'!
Object subclass: #CartSession
	instanceVariableNames: 'cart id lastUsed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CartSession methodsFor: 'initialization' stamp: 'DA 6/14/2023 23:31:04' prior: 50628386!
initializeInitiateSessionOf: aCart withId: aCartId startingAt: aDate 
	cart := aCart.
	id := aCartId.
	lastUsed := aDate.! !
!CartSession methodsFor: 'initialization' stamp: 'DA 6/14/2023 23:31:38'!
isExpired: aDatetime
	! !
!CartSession methodsFor: 'initialization' stamp: 'DA 6/14/2023 23:32:21' prior: 50628416!
isExpired: aDatetime
	^ (aDatetime - lastUsed) > (Duration minutes: 30). ! !

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:32:41'!
FAILURE!

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:32:41'!
FAILURE!
!CartSession methodsFor: 'nil' stamp: 'DA 6/14/2023 23:34:04'!
updateLastUsed: aDatetime
	lastUsed := aDatetime! !
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:34:29' prior: 50628226!
test13CartNotAddingItemsWithExpiredSesion

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:34:51'!
ERROR!
!CartSession methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:36:07'!
id 
	^ id! !

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:36:29'!
ERROR!

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:36:48'!
ERROR!
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:36:57' prior: 50628437!
test13CartNotAddingItemsWithExpiredSesion

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	self
		should: [interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !

!testRun: #RestInterfaceTest #test13CartNotAddingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:37:00'!
PASSED!

!testRun: #RestInterfaceTest #test14CartNotListingItemsWithExpiredSesion stamp: 'DA 6/14/2023 23:37:04'!
PASSED!
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:38:18'!
test15CartNotCheckoutWithExpiredSesion

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	self
		should: [interface listCartIdentifiedAs: cartId]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:39:04' prior: 50628496!
test15CartNotCheckoutWithExpiredSesion

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	self
		should: [interface 
			checkOutCartIdentifiedAs: cartId 
			withCreditCardNumbered: '1111222233334444' 
			ownedBy: 'Juan Perez' 
			expiringOn: testObjectsFactory notExpiredMonthOfYear ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:39:16' prior: 50628513!
test15CartNotCheckoutWithExpiredSesion

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	interface addMinutes: 31.
	
	self
		should: [interface 
			checkOutCartIdentifiedAs: cartId 
			withCreditCardNumbered: '1111222233334444' 
			ownedBy: 'Juan Perez' 
			expiringOn: testObjectsFactory notExpiredMonthOfYear ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !
!RestInterfaceTest methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:39:36' prior: 50628534!
test15CartNotCheckoutWithExpiredSesion

	| interface cartId |
	interface := self createDefaultInterface .

	cartId := interface createCartFor: self validUser authenticatedWith: self validUserPassword.
	interface add: self validBook quantity: 1 toCartIdentifiedAs: cartId.
	interface addMinutes: 31.
	
	self
		should: [interface 
			checkOutCartIdentifiedAs: cartId 
			withCreditCardNumbered: '1111222233334444' 
			ownedBy: 'Juan Perez' 
			expiringOn: testObjectsFactory notExpiredMonthOfYear ]
		raise: Error
		withExceptionDo: [ :anError |
			self assert: anError messageText = interface expiredTimeErrorDescription]
		
		
		! !

!testRun: #RestInterfaceTest #test15CartNotCheckoutWithExpiredSesion stamp: 'DA 6/14/2023 23:39:41'!
ERROR!

!testRun: #RestInterfaceTest #test15CartNotCheckoutWithExpiredSesion stamp: 'DA 6/14/2023 23:39:41'!
ERROR!
!CartSession methodsFor: 'nil' stamp: 'DA 6/14/2023 23:40:37'!
add: anAmount of: aBook
	cart add: anAmount of: aBook ! !

!testRun: #RestInterfaceTest #test15CartNotCheckoutWithExpiredSesion stamp: 'DA 6/14/2023 23:40:47'!
PASSED!
!RestInterface methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:42:51' prior: 50628163!
retrieveCart: aCartId

	^carts detect: [:aCart | aCart hasCartId: aCartId] ifNone: [ self signalInvalidCartId ].! !
!CartSession methodsFor: 'as yet unclassified' stamp: 'DA 6/14/2023 23:43:16'!
hasCartId: aCartId
	^ id = aCartId ! !

!methodRemoval: CartSession #id stamp: 'DA 6/14/2023 23:43:20'!
id 
	^ id!

----SNAPSHOT----(14 June 2023 23:43:36) CuisUniversity-5832.image priorSource: 9475802!

----SNAPSHOT----(14 June 2023 23:56:25) CuisUniversity-5832.image priorSource: 9502578!

----QUIT----(14 June 2023 23:57:51) CuisUniversity-5832.image priorSource: 9502667!

----STARTUP---- (15 June 2023 17:20:26) as D:\windows64\CuisUniversity-5832.image!


!classRemoval: #StoreTestObjectsFactory stamp: 'DA 6/15/2023 19:38:52'!
Object subclass: #StoreTestObjectsFactory
	instanceVariableNames: 'today'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #RestInterface stamp: 'DA 6/15/2023 19:38:53'!
Object subclass: #RestInterface
	instanceVariableNames: 'authenticationSystem carts catalog lastId merchantProcessor salesBook clock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CreditCard stamp: 'DA 6/15/2023 19:38:53'!
Object subclass: #CreditCard
	instanceVariableNames: 'expiration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cashier stamp: 'DA 6/15/2023 19:38:54'!
Object subclass: #Cashier
	instanceVariableNames: 'cart salesBook merchantProcessor creditCard total'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartSession stamp: 'DA 6/15/2023 19:38:55'!
Object subclass: #CartSession
	instanceVariableNames: 'cart id lastUsed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cart stamp: 'DA 6/15/2023 19:38:56'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #RestInterfaceTest stamp: 'DA 6/15/2023 19:38:56'!
TestCase subclass: #RestInterfaceTest
	instanceVariableNames: 'testObjectsFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CashierTest stamp: 'DA 6/15/2023 19:38:57'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testObjectsFactory debitBehavior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartTest stamp: 'DA 6/15/2023 19:38:57'!
TestCase subclass: #CartTest
	instanceVariableNames: 'testObjectsFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----End fileIn of C:\Users\daiana\Documents\GitHub\2023-1c\09-TusLibros\Iteracion3\Iteracion3\TusLibros-80.st----!

!classRemoval: #StoreTestObjectsFactory stamp: 'DA 6/15/2023 19:58:42'!
Object subclass: #StoreTestObjectsFactory
	instanceVariableNames: 'today'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!

----STARTUP---- (15 June 2023 20:44:25) as D:\windows64\CuisUniversity-5832.image!


!classRemoval: #StoreTestObjectsFactory stamp: 'DA 6/15/2023 20:44:35'!
Object subclass: #StoreTestObjectsFactory
	instanceVariableNames: 'today'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #RestInterface stamp: 'DA 6/15/2023 20:44:36'!
Object subclass: #RestInterface
	instanceVariableNames: 'authenticationSystem carts catalog lastId merchantProcessor salesBook clock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CreditCard stamp: 'DA 6/15/2023 20:44:36'!
Object subclass: #CreditCard
	instanceVariableNames: 'expiration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cashier stamp: 'DA 6/15/2023 20:44:36'!
Object subclass: #Cashier
	instanceVariableNames: 'cart salesBook merchantProcessor creditCard total'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartSession stamp: 'DA 6/15/2023 20:44:37'!
Object subclass: #CartSession
	instanceVariableNames: 'cart id lastUsed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cart stamp: 'DA 6/15/2023 20:44:37'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #RestInterfaceTest stamp: 'DA 6/15/2023 20:44:38'!
TestCase subclass: #RestInterfaceTest
	instanceVariableNames: 'testObjectsFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CashierTest stamp: 'DA 6/15/2023 20:44:38'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testObjectsFactory debitBehavior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartTest stamp: 'DA 6/15/2023 20:44:38'!
TestCase subclass: #CartTest
	instanceVariableNames: 'testObjectsFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----End fileIn of D:\windows64\Packages\System\Collections-CompactArrays.pck.st----!

----End fileIn of D:\windows64\Packages\Features\Compression.pck.st----!

----End fileIn of D:\windows64\Packages\Features\Sound.pck.st----!

----End fileIn of D:\windows64\Packages\Features\Cryptography-DigitalSignatures.pck.st----!

----End fileIn of D:\windows64\Packages\Features\Identities-UUID.pck.st----!

----End fileIn of D:\windows64\Packages\System\Network-Kernel.pck.st----!

----End fileIn of C:\Users\daiana\Documents\GitHub\2023-1c\09-TusLibros\Iteracion 4\ConsignaIteracion4\WebClient.pck.st----!

----End fileIn of C:\Users\daiana\Documents\GitHub\2023-1c\09-TusLibros\Iteracion 4\ConsignaIteracion4\TusLibrosREST Ejercicio it4.st----!

----End fileIn of C:\Users\daiana\Documents\GitHub\2023-1c\09-TusLibros\Iteracion 4\ConsignaIteracion4\TusLibros-Model Ejercicio it4.st----!

----End fileIn of C:\Users\daiana\Documents\GitHub\2023-1c\09-TusLibros\Iteracion 4\ConsignaIteracion4\TusLibros-Tests Ejercicio it4.st----!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'DA 6/15/2023 20:48:34'!
FAILURE!

----End fileIn of D:\windows64\Packages\TerseGuide.pck.st----!

TusLibrosClientTestWindow open !

TusLibrosServerRestInterface installForDefaultSystem.!

TusLibrosClientTestWindow open !

----STARTUP---- (22 June 2023 19:55:36) as D:\windows64\CuisUniversity-5832.image!


!classRemoval: #StoreTestObjectsFactory stamp: 'DA 6/22/2023 19:55:45'!
Object subclass: #StoreTestObjectsFactory
	instanceVariableNames: 'today'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #RestInterface stamp: 'DA 6/22/2023 19:55:45'!
Object subclass: #RestInterface
	instanceVariableNames: 'authenticationSystem carts catalog lastId merchantProcessor salesBook clock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CreditCard stamp: 'DA 6/22/2023 19:55:46'!
Object subclass: #CreditCard
	instanceVariableNames: 'expiration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cashier stamp: 'DA 6/22/2023 19:55:46'!
Object subclass: #Cashier
	instanceVariableNames: 'cart salesBook merchantProcessor creditCard total'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartSession stamp: 'DA 6/22/2023 19:55:46'!
Object subclass: #CartSession
	instanceVariableNames: 'cart id lastUsed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cart stamp: 'DA 6/22/2023 19:55:46'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #RestInterfaceTest stamp: 'DA 6/22/2023 19:55:47'!
TestCase subclass: #RestInterfaceTest
	instanceVariableNames: 'testObjectsFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CashierTest stamp: 'DA 6/22/2023 19:55:47'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testObjectsFactory debitBehavior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartTest stamp: 'DA 6/22/2023 19:55:47'!
TestCase subclass: #CartTest
	instanceVariableNames: 'testObjectsFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----End fileIn of C:\Users\daiana\Documents\GitHub\2023-1c\10-CustomerImporter\CustomerImporter.st----!

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 19:59:37'!
PASSED!
!Address methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:00' prior: 50630467!
zipCode: aZipCode

	zipCode := aZipCode! !
!Address methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:01' prior: 50630449!
streetNumber

	^streetNumber ! !
!Address methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:01' prior: 50630438!
province: aProvince

	province := aProvince
	! !
!Address methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:01' prior: 50630442!
streetName

	^streetName ! !
!Address methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:01' prior: 50630460!
town: aTown

	town := aTown! !
!Address methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:01' prior: 50630435!
province

	^province! !
!Address methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:01' prior: 50630453!
streetNumber: aStreetNumber

	streetNumber := aStreetNumber ! !
!Address methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:01' prior: 50630464!
zipCode

	^zipCode! !
!Address methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:01' prior: 50630457!
town

	^town! !
!Address methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:01' prior: 50630445!
streetName: aStreetName

	streetName := aStreetName ! !
!Customer methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:02' prior: 50630528 overrides: 16920235!
initialize

	super initialize.
	addresses := OrderedCollection new.! !
!Customer methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:02' prior: 50630497!
firstName: aName

	firstName := aName! !
!Customer methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:02' prior: 50630501!
lastName

	^lastName ! !
!Customer methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:02' prior: 50630491!
addresses

	^ addresses! !
!Customer methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:02' prior: 50630494!
firstName

	^firstName ! !
!Customer methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:02' prior: 50630518!
identificationType

	^identificationType ! !
!Customer methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:02' prior: 50630522!
identificationType: anIdentificationType

	identificationType := anIdentificationType! !
!Customer methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:02' prior: 50630512!
identificationNumber: anIdentificationNumber

	identificationNumber := anIdentificationNumber! !
!Customer methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:02' prior: 50630508!
identificationNumber

	^identificationNumber ! !
!Customer methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:02' prior: 50630504!
lastName: aLastName

	lastName := aLastName
! !
!Customer methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:02' prior: 50630487!
addAddress: anAddress

	addresses add: anAddress ! !
!Customer class methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:02' prior: 50630541!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!DataBaseSession methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:03' prior: 50630606!
close

	! !
!DataBaseSession methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:03' prior: 50630616!
delay

	(Delay forMilliseconds: 100) wait! !
!DataBaseSession methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:03' prior: 50630596!
beginTransaction

	! !
!DataBaseSession methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:03' prior: 50630626!
persistAddressesOf: anObjectWithAddresses

	anObjectWithAddresses addresses do: [ :anAddress | self persist: anAddress ]
	! !
!DataBaseSession methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:03' prior: 50630654!
select: aCondition ofType: aType

	self delay.
	^(self objectsOfType: aType) select: aCondition ! !
!DataBaseSession methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:03' prior: 50630633!
initializeFor: aConfiguration

	configuration := aConfiguration.
	tables := Dictionary new.
	id := 0.! !
!DataBaseSession methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:03' prior: 50630621!
objectsOfType: aType

	^ tables at: aType ifAbsent: [ #() ]! !
!DataBaseSession methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:03' prior: 50630610!
defineIdOf: anObject

	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !
!DataBaseSession methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:03' prior: 50630643!
persist: anObject

	| table |

	self delay.
	table := tables at: anObject class ifAbsentPut: [ Set new ].

	self defineIdOf: anObject.
	table add: anObject.

	(anObject isKindOf: Customer) ifTrue: [ self persistAddressesOf: anObject ].! !
!DataBaseSession methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:03' prior: 50630660!
selectAllOfType: aType

	self delay.
	^(self objectsOfType: aType) copy ! !
!DataBaseSession methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:03' prior: 50630600!
commit

	(tables at: Customer ifAbsent: [#()]) do: [ :aCustomer | self persistAddressesOf: aCustomer ]
	! !
!DataBaseSession methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:03' prior: 50630639!
newIdFor: anObject

	id := id + 1.
	^id! !
!DataBaseSession class methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:03' prior: 50630674!
for: aConfiguration

	^self new initializeFor: aConfiguration! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:01:04' prior: 50630417!
test01Import

	Customer importCustomers ! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:17:18' prior: 50630907!
test01Import
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:22:37'!
importCustomers
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:22:50' prior: 50630912!
test01Import
	self importCustomers.
	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:23:08'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:30:54' prior: 50630951!
importCustomers
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'DA 6/22/2023 20:30:54'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:32:23' overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:32:24' prior: 50630998!
importCustomers
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	self setUp.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:33:23' prior: 50631052!
importCustomers
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:33:30'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:34:20' overrides: 16961402!
tearDown

	session commit.
	session close! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:34:20' prior: 50631089!
importCustomers
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	self tearDown.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:34:34' prior: 50631133!
importCustomers
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:34:36'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:42:13' prior: 50630991!
test01Import
	|customers|
	
	self importCustomers.
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:42:15'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:42:16'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:43:07' prior: 50631207!
test01Import
	|customers|
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:44:01' prior: 50631220!
test01Import
	|customers|
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	self assert: customers first firstName equals: 'Pepe'.
	self assert: customers first lastName equals: 'Sanchez'.

	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:44:03'!
ERROR!

----End fileIn of D:\windows64\Packages\TerseGuide.pck.st----!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:48:27' prior: 50631228!
test01Import
	|customers|
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	self assert: customers firstName equals: 'Pepe'.
	self assert: customers lastName equals: 'Sanchez'.
	
	self assert: customers 

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:52:04' prior: 50634161!
test01Import
	|customers|
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	session select: '' ofType: Customer.

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:52:12' prior: 50634173!
test01Import
	|customers|
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	session select: 'Pepe' ofType: Customer.

	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:52:13'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:53:25' prior: 50634182!
test01Import
	|customers|
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	session select: [:customer | customer firstName = 'Pepe'] ofType: Customer.

	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:53:28'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:53:29'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:54:14' prior: 50634194!
test01Import
	|customers|
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	session select: [:customer | (customer firstName = 'Pepe') and: (customer lastName: 'Sanchez')] ofType: Customer.

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:54:41' prior: 50634209!
test01Import
	|customers|
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	session 
		select: [:customer | (customer firstName = 'Pepe') and: (customer lastName: 'Sanchez')] 
		ofType: Customer.

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:56:05' prior: 50634221!
test01Import
	|customers|
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	session 
		select: [:customer | 
			(customer firstName = 'Pepe') 
			and: (customer lastName: 'Sanchez') 
			and: (customer identificationType  = 'D')
			and: (customer identificationNumber = 22333444)] 
		ofType: Customer.

	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:56:08'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:56:20' prior: 50634233!
test01Import
	|customers|
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	session 
		select: [:customer | 
			(customer firstName = 'Pepe') 
			and: (customer lastName = 'Sanchez') 
			and: (customer identificationType  = 'D')
			and: (customer identificationNumber = 22333444)] 
		ofType: Customer.

	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:56:22'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:56:22'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:56:53' prior: 50634251!
test01Import
	|customers|
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	session 
		select: [:customer | 
			(customer firstName = 'Pepe') 
			and: (customer lastName = 'Sanchez') 
			and: (customer identificationType  = 'D')
			and: (customer identificationNumber = 22333444)] 
		ofType: Customer.

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:57:56' prior: 50634271!
test01Import
	|customers pepe|
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	pepe := session 
		select: [:customer | 
			(customer firstName = 'Pepe') 
			and: (customer lastName = 'Sanchez') 
			and: (customer identificationType  = 'D')
			and: (customer identificationNumber = 22333444)] 
		ofType: Customer.
	self assert: pepe isEmpty not.
	

	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:57:58'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 20:58:53' prior: 50634286!
test01Import
	|customers pepe|
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	pepe := session 
		select: [:customer | 
			(customer firstName = 'Pepe') 
			and: (customer lastName = 'Sanchez') 
			and: (customer identificationType  = 'D')
			and: (customer identificationNumber = '22333444')] 
		ofType: Customer.
	self assert: pepe isEmpty not.
	

	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 20:58:55'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:00:06' prior: 50634305!
test01Import
	|customers |
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	self assert: (session 
		select: [:customer | 
			(customer firstName = 'Pepe') 
			and: (customer lastName = 'Sanchez') 
			and: (customer identificationType  = 'D')
			and: (customer identificationNumber = '22333444')] 
		ofType: Customer) isEmpty not.
	
	
	

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:00:49' prior: 50634324!
test01Import
	|customers |
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.
	
	self assert: (session 
		select: [:customer | 
			(customer firstName = 'Pepe') 
			and: (customer lastName = 'Sanchez') 
			and: (customer identificationType  = 'D')
			and: (customer identificationNumber = '22333444')] 
		ofType: Customer) isEmpty not.
	
	
	
	

	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 21:00:51'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:01:15' prior: 50631169!
importCustomers
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 21:01:20'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 21:01:21'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:02:24' prior: 50634340!
test01Import
	|customers |
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.

	
	
	
	
	

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:02:37'!
test02Import
	
	
	self importCustomers.
	
	self assert: (session 
		select: [:customer | 
			(customer firstName = 'Pepe') 
			and: (customer lastName = 'Sanchez') 
			and: (customer identificationType  = 'D')
			and: (customer identificationNumber = '22333444')] 
		ofType: Customer) isEmpty not.

	
	
	
	
	

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:02:42' prior: 50634407!
test02Import
	
	self importCustomers.
	
	self assert: (session 
		select: [:customer | 
			(customer firstName = 'Pepe') 
			and: (customer lastName = 'Sanchez') 
			and: (customer identificationType  = 'D')
			and: (customer identificationNumber = '22333444')] 
		ofType: Customer) isEmpty not.

	
	
	
	
	

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:05:52' prior: 50634420!
test02Import
	
	self importCustomers.
	
	self assert: (session 
		select: [:customer | 
			(customer firstName = 'Pepe') 
			and: (customer lastName = 'Sanchez') 
			and: (customer identificationType  = 'D')
			and: (customer identificationNumber = '22333444')] 
		ofType: Customer) isEmpty not.
		
	self assert: (session 
		select: [:customer | 
			(customer firstName = 'Juan') 
			and: (customer lastName = 'Perez') 
			and: (customer identificationType  = 'C')
			and: (customer identificationNumber = '23-25666777-9')] 
		ofType: Customer) isEmpty not.

	
	
	
	
	

	! !

!testRun: #ImportTest #test02Import stamp: 'DA 6/22/2023 21:05:54'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 21:05:55'!
PASSED!

!testRun: #ImportTest #test02Import stamp: 'DA 6/22/2023 21:05:56'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:06:07' prior: 50634433!
test02Import
	
	self importCustomers.
	
	self assert: (session 
		select: [:customer | 
			(customer firstName = 'Pepe') 
			and: (customer lastName = 'Sanchez') 
			and: (customer identificationType  = 'D')
			and: (customer identificationNumber = '22333444')] 
		ofType: Customer) isEmpty not.
		
	self assert: (session 
		select: [:customer | 
			(customer firstName = 'Juan') 
			and: (customer lastName = 'Perez') 
			and: (customer identificationType  = 'C')
			and: (customer identificationNumber = '23-25666777-9')] 
		ofType: Customer) isEmpty not.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:07:30'!
test03Import
	
	| addressses |
	self importCustomers.
	
	addressses := session selectAllOfType: Address.
	self assert: addressses size equals: 3.! !

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:07:40'!
FAILURE!

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:08:58'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:12:28' prior: 50634482!
test03Import
	
	self importCustomers.
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:13:13' prior: 50634495!
test03Import
	
	self importCustomers.
	
	self assert: (session selectAllOfType: Address) size equals: 3.
	! !

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:13:16'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:13:58' prior: 50634462!
test02Import
	
	self importCustomers.
	
	self assert: (session 
		select: [:customer | 
			(customer identificationType  = 'D')
			and: (customer identificationNumber = '22333444')] 
		ofType: Customer) isEmpty not.
		
	self assert: (session 
		select: [:customer | 
			(customer identificationType  = 'C')
			and: (customer identificationNumber = '23-25666777-9')] 
		ofType: Customer) isEmpty not.! !

!testRun: #ImportTest #test02Import stamp: 'DA 6/22/2023 21:14:01'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 21:14:01'!
PASSED!

!testRun: #ImportTest #test02Import stamp: 'DA 6/22/2023 21:14:02'!
PASSED!

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:14:03'!
FAILURE!

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:14:03'!
FAILURE!

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:14:12'!
FAILURE!

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:15:22'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:26:48' prior: 50634500!
test03Import
	
	self importCustomers.
	
	self assert: (session select: [:customer | customer addresses] ofType: Customer).
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:28:02' prior: 50634542!
test03Import
	
	self importCustomers.
	
	self assert: (session select: [:customer | customer ] ofType: Customer).
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:29:43' prior: 50634549!
test03Import
	
	self importCustomers.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:30:46' prior: 50634556!
test03Import
	
	self importCustomers.
	
	self assert: (session selectAllOfType: Address size) equals: 3! !

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:38:34'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:48:35' prior: 50634561!
test03Import
	
	self importCustomers.
	
	self assert: (session select: [:customer | customer identificationType = 'C' and: customer identificationNumber = '23-25666777-9' and: (customer hasAddressinStreet: 'Alem' andNumber: '1122') ] ofType: Customer) isEmpty not.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:48:35' prior: 50634570!
test03Import
	
	self importCustomers.
	
	self assert: (session select: [:customer | customer identificationType = 'C' and: customer identificationNumber = '23-25666777-9' and: (customer hasAddressinStreet: 'Alem' andNumber: '1122') ] ofType: Customer) isEmpty not.! !

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:48:42'!
ERROR!
!Customer methodsFor: 'addresses' stamp: 'DA 6/22/2023 21:48:50'!
hasAddressinStreet: aRenameMe1 andNumber: aRenameMe2 
	self shouldBeImplemented.! !
!Customer methodsFor: 'addresses' stamp: 'DA 6/22/2023 21:55:19' prior: 50634595!
hasAddressinStreet: aStreetName andNumber: aStreetNumber
	^self addresses findFirst: [:address | address streetName = aStreetName and: address streetNumber = aStreetNumber] > 0! !

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:55:23'!
ERROR!
!Customer methodsFor: 'addresses' stamp: 'DA 6/22/2023 21:55:51' prior: 50634601!
hasAddressinStreet: aStreetName andNumber: aStreetNumber
	^(self addresses findFirst: [:address | address streetName = aStreetName and: address streetNumber = aStreetNumber]) > 0! !

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:55:57'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:57:29' prior: 50634359!
importCustomers
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth].

		line := inputStream nextLine. ].

	inputStream close.
	! !

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:57:33'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:01:15' prior: 50634624!
importCustomers
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 21:59:28' prior: 50634582!
test03Import
	
	self importCustomers.
	
	self assert: (session select: [:customer | customer identificationType = 'C' and: customer identificationNumber = '23-25666777-9' and: (customer hasAddressinStreet: 'Alem' andNumber: 1122) ] ofType: Customer) isEmpty not.! !

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:59:30'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 21:59:31'!
PASSED!

!testRun: #ImportTest #test02Import stamp: 'DA 6/22/2023 21:59:32'!
PASSED!

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 21:59:32'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/22/2023 22:00:30' prior: 50634697!
test03Import
	
	self importCustomers.
	
	self assert: (session select: [:customer | customer identificationType = 'C' and: customer identificationNumber = '23-25666777-9' and: (customer hasAddressinStreet: 'Alem' streetNumber: 1122 postalCode: 1001 province: 'CABA') ] ofType: Customer) isEmpty not.! !

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 22:00:35'!
ERROR!
!Customer methodsFor: 'addresses' stamp: 'DA 6/22/2023 22:00:40'!
hasAddressinStreet: aRenameMe1 streetNumber: aRenameMe2 postalCode: aRenameMe3 province: aRenameMe4 
	self shouldBeImplemented.! !
!Customer methodsFor: 'addresses' stamp: 'DA 6/22/2023 22:01:05' prior: 50634732!
hasAddressinStreet: aStreetName streetNumber: aStreetNumber postalCode: aPostalCode province: aProvince
	self shouldBeImplemented.! !
!Customer methodsFor: 'addresses' stamp: 'DA 6/22/2023 22:02:07' prior: 50634739!
hasAddressinStreet: aStreetName streetNumber: aStreetNumber postalCode: aPostalCode province: aProvince
	^(self addresses 
			findFirst: [:address |
					address streetName = aStreetName 
					and: address streetNumber = aStreetNumber
					and: address zipCode = aPostalCode 
					and: address province = aProvince 
					]) > 0! !

!methodRemoval: Customer #hasAddressinStreet:andNumber: stamp: 'DA 6/22/2023 22:02:12'!
hasAddressinStreet: aStreetName andNumber: aStreetNumber
	^(self addresses findFirst: [:address | address streetName = aStreetName and: address streetNumber = aStreetNumber]) > 0!

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 22:02:19'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'DA 6/22/2023 22:02:20'!
PASSED!

!testRun: #ImportTest #test02Import stamp: 'DA 6/22/2023 22:02:21'!
PASSED!

!testRun: #ImportTest #test03Import stamp: 'DA 6/22/2023 22:02:21'!
PASSED!

----QUIT----(22 June 2023 22:06:08) CuisUniversity-5832.image priorSource: 9502756!

----STARTUP---- (25 June 2023 18:24:32) as D:\windows64\CuisUniversity-5832.image!

!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:36:23'!
addressSanMartin 
	|address|
	address := Address new.
	address streetName: 'San Martin'.
	address streetNumber: 3322.
	address town: '	Olivos'.
	address zipCode: 1636.
	address province: 'BsAs'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:36:31' prior: 50634783!
addressSanMartin 
	|address|
	address := Address new.
	address streetName: 'San Martin'.
	address streetNumber: 3322.
	address town: '	Olivos'.
	address zipCode: 1636.
	address province: 'BsAs'.
	^ address ! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:37:04'!
addressMaipu
	|address|
	address := Address new.
	address streetName: 'Maipu'.
	address streetNumber: 888.
	address town: '	Florida'.
	address zipCode: 1122.
	address province: 'Buenos Aires'.
	^ address ! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:37:28'!
addressAlem
	|address|
	address := Address new.
	address streetName: 'Alem'.
	address streetNumber: 1122.
	address town: '	CABA'.
	address zipCode: 1001.
	address province: 'CABA'.
	^ address ! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:38:47'!
customerPepe
	|customer|
	customer := Customer new.
	customer firstName: 'Pepe'.
	customer lastName: 'Sanchez'.
	customer identificationNumber: '22333444'.
	customer identificationType: 'D'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:39:09'!
customerJuan
	|customer|
	customer := Customer new.
	customer firstName: 'Juan'.
	customer lastName: 'Perez'.
	customer identificationNumber: '23-25666777-9'.
	customer identificationType: 'C'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:39:51' prior: 50634509!
test02Import
	
	self importCustomers.
	
	self assert: (session 
		select: [:customer | customer = self customerPepe] 
		ofType: Customer) isEmpty not.
		
	self assert: (session 
		select: [:customer | customer = self customerJuan ] 
		ofType: Customer) isEmpty not.! !

!testRun: #ImportTest #test02Import stamp: 'DA 6/25/2023 18:39:56'!
FAILURE!

!testRun: #ImportTest #test02Import stamp: 'DA 6/25/2023 18:39:56'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:40:08' prior: 50634829!
customerJuan
	|customer|
	customer := Customer new.
	customer firstName: 'Juan'.
	customer lastName: 'Perez'.
	customer identificationNumber: '23-25666777-9'.
	customer identificationType: 'C'.
	^customer! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:40:13' prior: 50634820!
customerPepe
	|customer|
	customer := Customer new.
	customer firstName: 'Pepe'.
	customer lastName: 'Sanchez'.
	customer identificationNumber: '22333444'.
	customer identificationType: 'D'.
	^customer! !

!testRun: #ImportTest #test02Import stamp: 'DA 6/25/2023 18:40:16'!
FAILURE!

!testRun: #ImportTest #test02Import stamp: 'DA 6/25/2023 18:40:17'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:44:19'!
assertCustomer: aCustomer equals: anotherCustomer
	self assert: aCustomer firstName equals: anotherCustomer firstName.
	self assert: aCustomer lastName equals: anotherCustomer lastName.
	self assert: aCustomer identificationType equals: anotherCustomer identificationType.
	self assert: aCustomer identificationNumber equals: anotherCustomer identificationNumber.

	
	
	
	
	

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:48:12' prior: 50634839!
test02Import
	
	|customerPepe customerJuan|
	self importCustomers.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
		
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] 
		ofType: Customer) anyOne.
	self assertCustomer: customerJuan equals: self customerJuan.! !

!testRun: #ImportTest #test02Import stamp: 'DA 6/25/2023 18:48:16'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:48:28' prior: 50634895!
test02Import
	
	|customerPepe customerJuan|
	self importCustomers.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
		
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: customerJuan equals: self customerJuan.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:50:18'!
assertLocation: aLocation equals: anotherLocation
	self assert: aLocation streetName equals: anotherLocation streetName.
	self assert: aLocation streetNumber equals: anotherLocation streetNumber.
	self assert: aLocation town equals: anotherLocation town.
	self assert: aLocation zipCode equals: anotherLocation zipCode.

	
	
	
	
	

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:50:53' prior: 50634930!
assertLocation: aLocation equals: anotherLocation
	self assert: aLocation streetName equals: anotherLocation streetName.
	self assert: aLocation streetNumber equals: anotherLocation streetNumber.
	self assert: aLocation town equals: anotherLocation town.
	self assert: aLocation zipCode equals: anotherLocation zipCode.
	self assert: aLocation province equals: anotherLocation province.

	
	
	
	
	

	! !
!Customer methodsFor: 'addresses' stamp: 'DA 6/25/2023 18:53:01'!
addressAt: aStreetName
	^ addresses 
		detect: [ :anAddress | anAddress hasStreetName: aStreetName ]
		ifNone: [ self error: self class invalidStreetNameDescriptionError]! !

!methodRemoval: Customer #hasAddressinStreet:streetNumber:postalCode:province: stamp: 'DA 6/25/2023 18:54:35'!
hasAddressinStreet: aStreetName streetNumber: aStreetNumber postalCode: aPostalCode province: aProvince
	^(self addresses 
			findFirst: [:address |
					address streetName = aStreetName 
					and: address streetNumber = aStreetNumber
					and: address zipCode = aPostalCode 
					and: address province = aProvince 
					]) > 0!
!Address methodsFor: 'nil' stamp: 'DA 6/25/2023 18:55:00'!
hasStreetName: aStreetName
	^ self streetName = aStreetName ! !
!Customer class methodsFor: 'nil' stamp: 'DA 6/25/2023 18:55:44'!
invalidStreetNameDescriptionError
	^ 'Received an invalid streetname'! !
!Customer methodsFor: 'addresses' stamp: 'DA 6/25/2023 18:56:03'!
addressesSize

	^ addresses size! !

!methodRemoval: ImportTest #test03Import stamp: 'DA 6/25/2023 18:56:26'!
test03Import
	
	self importCustomers.
	
	self assert: (session select: [:customer | customer identificationType = 'C' and: customer identificationNumber = '23-25666777-9' and: (customer hasAddressinStreet: 'Alem' streetNumber: 1122 postalCode: 1001 province: 'CABA') ] ofType: Customer) isEmpty not.!

!methodRemoval: ImportTest #test01Import stamp: 'DA 6/25/2023 18:56:51'!
test01Import
	|customers |
	
	self importCustomers.
	
	customers := session selectAllOfType: Customer.
	self assert: customers size equals: 2.

	
	
	
	
	

	!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:57:04'!
test01Import
	
	|customerPepe customerJuan|
	self importCustomers.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
		
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: customerJuan equals: self customerJuan.! !

!methodRemoval: ImportTest #test02Import stamp: 'DA 6/25/2023 18:57:04'!
test02Import
	
	|customerPepe customerJuan|
	self importCustomers.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
		
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: customerJuan equals: self customerJuan.!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:58:46' prior: 50635014!
test01Import
	
	|customerPepe customerJuan addressMaipu |
	self importCustomers.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
		
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: customerJuan equals: self customerJuan.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assertLocation: addressMaipu equals: self addressMaipu.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 18:59:21' prior: 50635046!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin |
	self importCustomers.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
		
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: customerJuan equals: self customerJuan.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assertLocation: addressMaipu equals: self addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertLocation: addressSanMartin equals: self addressSanMartin .
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:00:31' prior: 50635069!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	self importCustomers.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assertLocation: addressMaipu equals: self addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertLocation: addressSanMartin equals: self addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: customerJuan equals: self customerJuan.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertLocation: addressAlem equals: self addressAlem.

	

	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:01:36' prior: 50635096!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	self importCustomers.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	self assert: customerPepe addressesSize = 2.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assertLocation: addressMaipu equals: self addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertLocation: addressSanMartin equals: self addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: customerJuan equals: self customerJuan.
	
	self assert: customerJuan addressesSize = 1.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertLocation: addressAlem equals: self addressAlem.

	

	
	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:01:40'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:01:41'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:02:06'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:02:58' prior: 50634662!
importCustomers
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth].

		line := inputStream nextLine. ].

	inputStream close.
	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:03:03'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:03:04'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:05:33' prior: 50635169!
importCustomers
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth.].

		line := inputStream nextLine. ].

	inputStream close.
	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:08:40'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:09:15'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:09:16'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:10:13'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:10:34' prior: 50635127!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	self importCustomers.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	self assert: customerPepe addressesSize = 2.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	"self assertLocation: addressMaipu equals: self addressMaipu."
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertLocation: addressSanMartin equals: self addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: customerJuan equals: self customerJuan.
	
	self assert: customerJuan addressesSize = 1.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertLocation: addressAlem equals: self addressAlem.

	

	
	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:10:38'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:10:39'!
FAILURE!

----QUIT----(25 June 2023 19:10:53) CuisUniversity-5832.image priorSource: 9700043!

----STARTUP---- (25 June 2023 19:11:15) as D:\windows64\CuisUniversity-5832.image!


!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:11:26'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:11:26'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:12:35' prior: 50635254!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	self importCustomers.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	self assert: customerPepe addressesSize = 2.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assertLocation: self addressMaipu equals: addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertLocation: self addressSanMartin equals: addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: self customerJuan equals: customerJuan.
	
	self assert: customerJuan addressesSize = 1.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertLocation: self addressAlem equals: addressAlem 

	

	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:12:36' prior: 50635303!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	self importCustomers.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	self assert: customerPepe addressesSize = 2.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assertLocation: self addressMaipu equals: addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertLocation: self addressSanMartin equals: addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: self customerJuan equals: customerJuan.
	
	self assert: customerJuan addressesSize = 1.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertLocation: self addressAlem equals: addressAlem.

	

	
	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:12:40'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:12:41'!
FAILURE!
!Address methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:13:44' prior: 50634981!
hasStreetName: aStreetName
	^ streetName = aStreetName ! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:13:50'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:13:51'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:19:44'!
assertAdress: aLocation equals: anotherLocation
	self assert: aLocation streetName equals: anotherLocation streetName.
	self assert: aLocation streetNumber equals: anotherLocation streetNumber.
	self assert: aLocation town equals: anotherLocation town.
	self assert: aLocation zipCode equals: anotherLocation zipCode.
	self assert: aLocation province equals: anotherLocation province.

	
	
	
	
	

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:19:44' prior: 50635337!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	self importCustomers.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	self assert: customerPepe addressesSize = 2.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assertAdress: self addressMaipu equals: addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertAdress: self addressSanMartin equals: addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: self customerJuan equals: customerJuan.
	
	self assert: customerJuan addressesSize = 1.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertAdress: self addressAlem equals: addressAlem.

	

	
	! !

!methodRemoval: ImportTest #assertLocation:equals: stamp: 'DA 6/25/2023 19:19:44'!
assertLocation: aLocation equals: anotherLocation
	self assert: aLocation streetName equals: anotherLocation streetName.
	self assert: aLocation streetNumber equals: anotherLocation streetNumber.
	self assert: aLocation town equals: anotherLocation town.
	self assert: aLocation zipCode equals: anotherLocation zipCode.
	self assert: aLocation province equals: anotherLocation province.

	
	
	
	
	

	!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:19:59'!
assertAddress: aLocation equals: anotherLocation
	self assert: aLocation streetName equals: anotherLocation streetName.
	self assert: aLocation streetNumber equals: anotherLocation streetNumber.
	self assert: aLocation town equals: anotherLocation town.
	self assert: aLocation zipCode equals: anotherLocation zipCode.
	self assert: aLocation province equals: anotherLocation province.

	
	
	
	
	

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:19:59' prior: 50635402!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	self importCustomers.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	self assert: customerPepe addressesSize = 2.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assertAddress: self addressMaipu equals: addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertAddress: self addressSanMartin equals: addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: self customerJuan equals: customerJuan.
	
	self assert: customerJuan addressesSize = 1.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertAddress: self addressAlem equals: addressAlem.

	

	
	! !

!methodRemoval: ImportTest #assertAdress:equals: stamp: 'DA 6/25/2023 19:19:59'!
assertAdress: aLocation equals: anotherLocation
	self assert: aLocation streetName equals: anotherLocation streetName.
	self assert: aLocation streetNumber equals: anotherLocation streetNumber.
	self assert: aLocation town equals: anotherLocation town.
	self assert: aLocation zipCode equals: anotherLocation zipCode.
	self assert: aLocation province equals: anotherLocation province.

	
	
	
	
	

	!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:20:20' prior: 50635451!
assertAddress: anAddress equals: anotherLocation
	self assert: anAddress streetName equals: anotherLocation streetName.
	self assert: anAddress streetNumber equals: anotherLocation streetNumber.
	self assert: anAddress town equals: anotherLocation town.
	self assert: anAddress zipCode equals: anotherLocation zipCode.
	self assert: anAddress province equals: anotherLocation province.

	
	
	
	
	

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:20:31' prior: 50635516!
assertAddress: anAddress equals: expectedAddress
	self assert: anAddress streetName equals: expectedAddress streetName.
	self assert: anAddress streetNumber equals: expectedAddress streetNumber.
	self assert: anAddress town equals: expectedAddress town.
	self assert: anAddress zipCode equals: expectedAddress zipCode.
	self assert: anAddress province equals: expectedAddress province.

	
	
	
	
	

	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:21:18'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:21:19'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:24:15' prior: 50635532!
assertAddress: anAddress equals: expectedAddress
	self assert: anAddress streetName equals: expectedAddress streetName.
	self assert: anAddress streetNumber equals: expectedAddress streetNumber.
	self assert: anAddress town equals: expectedAddress town.
	self assert: anAddress zipCode equals: expectedAddress zipCode.
	self assert: anAddress province equals: expectedAddress province.! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:24:15'!
FAILURE!
!ExtractToMethodObjectForm methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:25:47'!
shouldAutoHighlight
	self shouldBeImplemented.! !
!ExtractToMethodObjectForm methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:26:00' prior: 50635571!
shouldAutoHighlight
	^false! !

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'DA 6/25/2023 19:28:07'!
Object subclass: #CustomerImporter
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!CustomerImporter class methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:28:07'!
initializeFor: aSession
	^self new initializeInitializeFor: aSession! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:28:07'!
initializeInitializeFor: aSession
	session := aSession.! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:28:07' overrides: 16902254!
value
	| inputStream  newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth.].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:28:07' prior: 50635209!
importCustomers
	(CustomerImporter initializeFor: session) value! !
!CustomerImporter methodsFor: 'initialization' stamp: 'DA 6/25/2023 19:28:28'!
initializeFor: aSession
	session := aSession.! !
!CustomerImporter class methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:28:28' prior: 50635588!
initializeFor: aSession
	^self new initializeFor: aSession! !

!methodRemoval: CustomerImporter #initializeInitializeFor: stamp: 'DA 6/25/2023 19:28:28'!
initializeInitializeFor: aSession
	session := aSession.!

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'DA 6/25/2023 19:29:24'!
Object subclass: #CustomerImporter
	instanceVariableNames: 'session readStream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!CustomerImporter methodsFor: 'initialization' stamp: 'DA 6/25/2023 19:29:21'!
initializeFor: aStream into: aSession
	session := aSession.
	readStream := aStream.! !

!methodRemoval: CustomerImporter #initializeFor: stamp: 'DA 6/25/2023 19:29:30'!
initializeFor: aSession
	session := aSession.!
!CustomerImporter methodsFor: 'evaluating' stamp: 'DA 6/25/2023 19:29:52' prior: 50635599 overrides: 16902254!
value
	| inputStream  newCustomer line |

	"inputStream := UniFileStream new open: 'input.txt' forWrite: false."
	inputStream := readStream.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth.].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:32:09' prior: 50635467!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	(CustomerImporter initializeFor: self inputData into: session) value.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	self assert: customerPepe addressesSize = 2.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assertAddress: self addressMaipu equals: addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertAddress: self addressSanMartin equals: addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: self customerJuan equals: customerJuan.
	
	self assert: customerJuan addressesSize = 1.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertAddress: self addressAlem equals: addressAlem.

	

	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:32:55'!
inputData
	^ ReadStream on: 
	'C,Pepe,Sanchez,D,22333444
	A,San Martin,3322,Olivos,1636,BsAs
	A,Maipu,888,Florida,1122,Buenos Aires
	C,Juan,Perez,C,23-25666777-9
	A,Alem,1122,CABA,1001,CABA'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:33:07' prior: 50635744!
inputData
	^ ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA'.! !

!methodRemoval: ImportTest #importCustomers stamp: 'DA 6/25/2023 19:33:14'!
importCustomers
	(CustomerImporter initializeFor: session) value!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:33:18'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:33:18'!
ERROR!
!CustomerImporter class methodsFor: 'instance creation' stamp: 'DA 6/25/2023 19:33:49'!
initializeFor: aStream into: aSession
	^self new initializeFor: aStream into: aSession! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:33:56'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:33:57'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:34:11' prior: 50635709!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	(CustomerImporter initializeFor: self inputData into: session) value.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	self assert: customerPepe addressesSize = 2.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assertAddress: self addressMaipu equals: addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertAddress: self addressSanMartin equals: addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: self customerJuan equals: customerJuan.
	
	self assert: customerJuan addressesSize = 1.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertAddress: self addressAlem equals: addressAlem.
	! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'DA 6/25/2023 19:34:37' prior: 50635673 overrides: 16902254!
value
	| inputStream  newCustomer line |
	inputStream := readStream.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth.].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:37:47' prior: 50635553!
assertAddress: anAddress equals: expectedAddress
	self assert: anAddress streetName equals: expectedAddress streetName.
	self assert: anAddress streetNumber equals: expectedAddress streetNumber.
	self assert: expectedAddress town equals: anAddress town.
	self assert: anAddress zipCode equals: expectedAddress zipCode.
	self assert: anAddress province equals: expectedAddress province.! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:37:51'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:37:51'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:37:47' prior: 50635853!
assertAddress: anAddress equals: expectedAddress
	self assert: anAddress streetName equals: expectedAddress streetName.
	self assert: anAddress streetNumber equals: expectedAddress streetNumber.
	self assert: expectedAddress town equals: anAddress town.
	self assert: anAddress zipCode equals: expectedAddress zipCode.
	self assert: anAddress province equals: expectedAddress province.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:37:47' prior: 50635873!
assertAddress: anAddress equals: expectedAddress
	self assert: anAddress streetName equals: expectedAddress streetName.
	self assert: anAddress streetNumber equals: expectedAddress streetNumber.
	self assert: expectedAddress town equals: anAddress town.
	self assert: anAddress zipCode equals: expectedAddress zipCode.
	self assert: anAddress province equals: expectedAddress province.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'DA 6/25/2023 19:38:37' prior: 50635889!
assertAddress: anAddress equals: expectedAddress
	self assert: anAddress streetName equals: expectedAddress streetName.
	self assert: anAddress streetNumber equals: expectedAddress streetNumber.
	self assert: anAddress town equals: expectedAddress town.
	self assert: anAddress zipCode equals: expectedAddress zipCode.
	self assert: anAddress province equals: expectedAddress province.! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:40:39'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:40:40'!
FAILURE!

!methodRemoval: Customer class #importCustomers stamp: 'DA 6/25/2023 19:44:25'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := UniFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	!

!methodRemoval: CustomerImporter class #initializeFor: stamp: 'DA 6/25/2023 19:44:44'!
initializeFor: aSession
	^self new initializeFor: aSession!
!Customer methodsFor: 'addresses' stamp: 'DA 6/25/2023 19:45:56'!
numberOfAddress

	^ addresses size! !

!methodRemoval: Customer #addressesSize stamp: 'DA 6/25/2023 19:45:56'!
addressesSize

	^ addresses size!
!ImportTest methodsFor: 'tests' stamp: 'DA 6/25/2023 19:46:12' prior: 50635783!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	(CustomerImporter initializeFor: self inputData into: session) value.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	self assert: customerPepe numberOfAddress = 2.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assertAddress: self addressMaipu equals: addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertAddress: self addressSanMartin equals: addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: self customerJuan equals: customerJuan.
	
	self assert: customerJuan numberOfAddress = 1.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertAddress: self addressAlem equals: addressAlem.
	! !

----SNAPSHOT----(25 June 2023 19:46:23) CuisUniversity-5832.image priorSource: 9716536!
!ImportTest methodsFor: 'assertions' stamp: 'DA 6/25/2023 19:49:08' prior: 50635905!
assertAddress: anAddress equals: expectedAddress
	self assert: anAddress streetName = expectedAddress streetName.
	self assert: anAddress streetNumber = expectedAddress streetNumber.
	self assert: anAddress town = expectedAddress town.
	self assert: anAddress zipCode = expectedAddress zipCode.
	self assert: anAddress province = expectedAddress province.! !
!ImportTest methodsFor: 'mocking' stamp: 'DA 6/25/2023 19:54:59' prior: 50634793!
addressSanMartin 
	|anAddress|
	anAddress := Address new.
	anAddress streetName: 'San Martin'.
	anAddress streetNumber: 3322.
	anAddress town: '	Olivos'.
	anAddress zipCode: 1636.
	anAddress province: 'BsAs'.
	^ anAddress ! !
!ImportTest methodsFor: 'mocking' stamp: 'DA 6/25/2023 19:55:07' prior: 50634802!
addressMaipu
	|anAddress|
	anAddress := Address new.
	anAddress streetName: 'Maipu'.
	anAddress streetNumber: 888.
	anAddress town: '	Florida'.
	anAddress zipCode: 1122.
	anAddress province: 'Buenos Aires'.
	^ anAddress ! !
!ImportTest methodsFor: 'mocking' stamp: 'DA 6/25/2023 19:55:17' prior: 50634811!
addressAlem
	|anAddress|
	anAddress := Address new.
	anAddress streetName: 'Alem'.
	anAddress streetNumber: 1122.
	anAddress town: '	CABA'.
	anAddress zipCode: 1001.
	anAddress province: 'CABA'.
	^ anAddress ! !
!ImportTest methodsFor: 'mocking' stamp: 'DA 6/25/2023 19:55:31' prior: 50634856!
customerJuan
	|aCustomer|
	aCustomer := Customer new.
	aCustomer firstName: 'Juan'.
	aCustomer lastName: 'Perez'.
	aCustomer identificationNumber: '23-25666777-9'.
	aCustomer identificationType: 'C'.
	^aCustomer! !
!ImportTest methodsFor: 'mocking' stamp: 'DA 6/25/2023 19:55:38' prior: 50634866!
customerPepe
	|aCustomer|
	aCustomer := Customer new.
	aCustomer firstName: 'Pepe'.
	aCustomer lastName: 'Sanchez'.
	aCustomer identificationNumber: '22333444'.
	aCustomer identificationType: 'D'.
	^aCustomer! !
!ImportTest methodsFor: 'assertions' stamp: 'DA 6/25/2023 19:56:42' prior: 50636015!
assertAddress: anAddress equals: expectedAddress
	self assert: anAddress streetName equals: expectedAddress streetName.
	self assert: anAddress streetNumber equals: expectedAddress streetNumber.
	self assert: anAddress town equals: expectedAddress town.
	self assert: anAddress zipCode equals: expectedAddress zipCode.
	self assert: anAddress province equals: expectedAddress province.! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:56:50'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:56:51'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:57:43'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'DA 6/25/2023 19:59:07' prior: 50635977!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	(CustomerImporter initializeFor: self inputData into: session) value.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	self assert: customerPepe numberOfAddress = 2.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assert: addressMaipu town equals: 'Florida'.
	self assertAddress: self addressMaipu equals: addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertAddress: self addressSanMartin equals: addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: self customerJuan equals: customerJuan.
	
	self assert: customerJuan numberOfAddress = 1.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertAddress: self addressAlem equals: addressAlem.
	! !
!ImportTest methodsFor: 'tests' stamp: 'DA 6/25/2023 19:59:33' prior: 50636101!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	(CustomerImporter initializeFor: self inputData into: session) value.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	self assert: customerPepe numberOfAddress = 2.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assert: self addressMaipu town equals: 'Florida'.
	self assertAddress: self addressMaipu equals: addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertAddress: self addressSanMartin equals: addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: self customerJuan equals: customerJuan.
	
	self assert: customerJuan numberOfAddress = 1.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertAddress: self addressAlem equals: addressAlem.
	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 19:59:44'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'DA 6/25/2023 20:00:04' prior: 50636138!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	(CustomerImporter initializeFor: self inputData into: session) value.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	self assert: customerPepe numberOfAddress = 2.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assert: self addressMaipu town = 'Florida'.
	self assertAddress: self addressMaipu equals: addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertAddress: self addressSanMartin equals: addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: self customerJuan equals: customerJuan.
	
	self assert: customerJuan numberOfAddress = 1.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertAddress: self addressAlem equals: addressAlem.
	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 20:00:26'!
FAILURE!
!ImportTest methodsFor: 'mocking' stamp: 'DA 6/25/2023 20:01:49' prior: 50636039!
addressMaipu
	|anAddress|
	anAddress := Address new.
	anAddress streetName: 'Maipu'.
	anAddress streetNumber: 888.
	anAddress town: 'Florida'.
	anAddress zipCode: 1122.
	anAddress province: 'Buenos Aires'.
	^ anAddress ! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 20:02:21'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 20:02:21'!
FAILURE!
!ImportTest methodsFor: 'mocking' stamp: 'DA 6/25/2023 20:02:59' prior: 50636029!
addressSanMartin 
	|anAddress|
	anAddress := Address new.
	anAddress streetName: 'San Martin'.
	anAddress streetNumber: 3322.
	anAddress town: 'Olivos'.
	anAddress zipCode: 1636.
	anAddress province: 'BsAs'.
	^ anAddress ! !
!ImportTest methodsFor: 'mocking' stamp: 'DA 6/25/2023 20:03:10' prior: 50636049!
addressAlem
	|anAddress|
	anAddress := Address new.
	anAddress streetName: 'Alem'.
	anAddress streetNumber: 1122.
	anAddress town: 'CABA'.
	anAddress zipCode: 1001.
	anAddress province: 'CABA'.
	^ anAddress ! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 20:03:16'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'DA 6/25/2023 20:03:23' prior: 50636177!
test01Import
	
	|customerPepe customerJuan addressMaipu addressSanMartin addressAlem |
	(CustomerImporter initializeFor: self inputData into: session) value.

	self assert: (session selectAllOfType: Customer) size equals: 2.

	customerPepe := (session
		select: [:customer | customer identificationType = 'D'] ofType: Customer) anyOne.
	self assertCustomer: customerPepe equals: self customerPepe.
	
	self assert: customerPepe numberOfAddress = 2.
	
	addressMaipu := customerPepe addressAt: 'Maipu'.
	self assertAddress: self addressMaipu equals: addressMaipu.
	
	addressSanMartin := customerPepe addressAt: 'San Martin'.
	self assertAddress: self addressSanMartin equals: addressSanMartin.
	
	customerJuan := (session 
		select: [:customer | customer identificationType = 'C'] ofType: Customer) anyOne.
	self assertCustomer: self customerJuan equals: customerJuan.
	
	self assert: customerJuan numberOfAddress = 1.
	
	addressAlem := customerJuan addressAt: 'Alem'.
	self assertAddress: self addressAlem equals: addressAlem.
	! !

!testRun: #ImportTest #test01Import stamp: 'DA 6/25/2023 20:03:33'!
PASSED!

----SNAPSHOT----(25 June 2023 20:03:44) CuisUniversity-5832.image priorSource: 9739557!